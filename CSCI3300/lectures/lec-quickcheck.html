<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - QuickCheck':' Type-directed Property Testing</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - QuickCheck':' Type-directed Property Testing </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
	<a href="../lectures.html">Lectures</a>
	<a href="../links.html">Links</a>
        <a href="https://piazza.com/gru/fall2016/csci3300/home">Piazza</a>
        </div>
       
	<br />
	<br />
	<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Testing</span> <span class="kw">where</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span> <span class="kw">hiding</span> ((===))
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span>
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.State</span> <span class="kw">hiding</span> (when)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;$&gt;))</code></pre></div>
<p>This note was originally authored by <a href="https://ranjitjhala.github.io/">Ranjit Jhala</a>, but slightly modified by Harley Eades.</p>
<p>In this lecture, we will look at <a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/">QuickCheck</a>, a technique that cleverly exploits typeclasses and monads to deliver a powerful automatic testing methodology.</p>
<p>Quickcheck was developed by <a href="http://www.cse.chalmers.se/~koen/">Koen Claessen</a> and <a href="http://www.cse.chalmers.se/~rjmh">John Hughes</a> more than ten years ago, and has since been ported to other languages and is currently used, among other things to find subtle <a href="http://video.google.com/videoplay?docid=4655369445141008672#">concurrency bugs</a> in <a href="http://www.erlang-factory.com/upload/presentations/55/TestingErlangProgrammesforMulticore.pdf">telecommunications code</a>.</p>
<p>The key idea on which QuickCheck is founded, is <em>property-based testing</em>. That is, instead of writing individual test cases (eg unit tests corresponding to input-output pairs for particular functions) one should write <em>properties</em> that are desired of the functions, and then <em>automatically</em> generate <em>random</em> tests which can be run to verify (or rather, falsify) the property.</p>
<p>By emphasizing the importance of specifications, QuickCheck yields several benefits:</p>
<ol style="list-style-type: decimal">
<li><p>The developer is forced to think about what the code <em>should do</em>,</p></li>
<li><p>The tool finds corner-cases where the specification is violated, which leads to either the code or the specification getting fixed,</p></li>
<li><p>The specifications live on as rich, machine-checkable documentation about how the code should behave.</p></li>
</ol>
<h1 id="properties">Properties</h1>
<p>A QuickCheck property is essentially a function whose output is a boolean. The standard “hello-world” QC property is</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_revapp ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_revapp xs ys <span class="fu">=</span> reverse (xs <span class="fu">++</span> ys) <span class="fu">==</span> reverse xs <span class="fu">++</span> reverse ys</code></pre></div>
<p>That is, a property looks a bit like a mathematical theorem that the programmer believes is true. A QC convention is to use the prefix <code>&quot;prop_&quot;</code> for QC properties. Note that the type signature for the property is not the usual polymorphic signature; we have given the concrete type <code>Int</code> for the elements of the list. This is because QC uses the types to generate random inputs, and hence is restricted to monomorphic properties (that don’t contain type variables.)</p>
<p>To <em>check</em> a property, we simply invoke the function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">quickCheck ::</span> (<span class="dt">Testable</span> prop) <span class="ot">=&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
  	<span class="co">-- Defined in Test.QuickCheck.Test</span></code></pre></div>
<p>lets try it on our example property above</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_revapp 
<span class="fu">***</span> <span class="dt">Failed</span><span class="fu">!</span> <span class="dt">Falsifiable</span> (after <span class="dv">2</span> tests and <span class="dv">1</span> shrink)<span class="fu">:</span>     
[<span class="dv">0</span>]
[<span class="dv">1</span>]</code></pre></div>
<p>Whats that ?! Well, lets run the <em>property</em> function on the two inputs</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> prop_revapp [<span class="dv">0</span>] [<span class="dv">1</span>] 
<span class="dt">False</span></code></pre></div>
<p>QC has found a sample input for which the property function <em>fails</em> ie, returns <code>False</code>. Of course, those of you who are paying attention will realize there was a bug in our property, namely it should be</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_revapp_ok ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_revapp_ok xs ys <span class="fu">=</span> reverse (xs <span class="fu">++</span> ys) <span class="fu">==</span> reverse ys <span class="fu">++</span> reverse xs</code></pre></div>
<p>because <code>reverse</code> will flip the order of the two parts <code>xs</code> and <code>ys</code> of <code>xs ++ ys</code>. Now, when we run</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> quickCheck prop_revapp_ok
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span></code></pre></div>
<p>That is, Haskell generated 100 test inputs and for all of those, the property held. You can up the stakes a bit by changing the number of tests you want to run</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; quickCheckN   ::</span> (<span class="dt">Testable</span> p) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">IO</span> () 
<span class="ot">&gt;</span> quickCheckN n <span class="fu">=</span> quickCheckWith <span class="fu">$</span> stdArgs { maxSuccess <span class="fu">=</span> n }</code></pre></div>
<p>and then do</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> quickCheckN <span class="dv">10000</span> prop_revapp_ok
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">10000</span> tests<span class="fu">.</span></code></pre></div>
<h2 id="quickcheck-quicksort">QuickCheck QuickSort</h2>
<p>Lets look at a slightly more interesting example. Here is the canonical implementation of <em>quicksort</em> in Haskell.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; qsort        ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> qsort []     <span class="fu">=</span> []
<span class="ot">&gt;</span> qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort lhs <span class="fu">++</span> [x] <span class="fu">++</span> qsort rhs
<span class="ot">&gt;</span>   <span class="kw">where</span> lhs  <span class="fu">=</span> [y <span class="fu">|</span> y <span class="ot">&lt;-</span> xs, y <span class="fu">&lt;</span> x]
<span class="ot">&gt;</span>         rhs  <span class="fu">=</span> [z <span class="fu">|</span> z <span class="ot">&lt;-</span> xs, z <span class="fu">&gt;</span> x]</code></pre></div>
<p>Really doesn’t need much explanation! Lets run it “by hand” on a few inputs</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> [<span class="dv">10</span>,<span class="dv">9</span><span class="fu">..</span><span class="dv">1</span>]
[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]
ghci<span class="fu">&gt;</span> qsort [<span class="dv">10</span>,<span class="dv">9</span><span class="fu">..</span><span class="dv">1</span>]
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]

ghci<span class="fu">&gt;</span> [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span><span class="dv">20</span>] <span class="fu">++</span> [<span class="dv">1</span>,<span class="dv">3</span><span class="fu">..</span><span class="dv">11</span>]
[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">14</span>,<span class="dv">16</span>,<span class="dv">18</span>,<span class="dv">20</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>]
ghci<span class="fu">&gt;</span> qsort <span class="fu">$</span> [<span class="dv">2</span>,<span class="dv">4</span><span class="fu">..</span><span class="dv">20</span>] <span class="fu">++</span> [<span class="dv">1</span>,<span class="dv">3</span><span class="fu">..</span><span class="dv">11</span>]
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">14</span>,<span class="dv">16</span>,<span class="dv">18</span>,<span class="dv">20</span>]</code></pre></div>
<p>Looks good – lets try to test that the output is in fact sorted. We need a function that checks that a list is ordered</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isOrdered ::</span>         (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isOrdered (x1<span class="fu">:</span>x2<span class="fu">:</span>xs) <span class="fu">=</span> x1 <span class="fu">&lt;=</span> x2 <span class="fu">&amp;&amp;</span> isOrdered (x2<span class="fu">:</span>xs)
<span class="ot">&gt;</span> isOrdered _          <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>and then we can use the above to write a property</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_qsort_isOrdered ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_qsort_isOrdered <span class="fu">=</span> isOrdered <span class="fu">.</span> qsort</code></pre></div>
<p>Lets test it!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">10000</span> prop_qsort_isOrdered 
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">10000</span> tests<span class="fu">.</span></code></pre></div>
<h2 id="conditional-properties">Conditional Properties</h2>
<p>Here are several other properties that we might want. First, repeated <code>qsorting</code> should not change the list. That is,</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_qsort_idemp ::</span>  [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span> 
<span class="ot">&gt;</span> prop_qsort_idemp xs <span class="fu">=</span> qsort (qsort xs) <span class="fu">==</span> qsort xs</code></pre></div>
<p>Second, the head of the result is the minimum element of the input</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_qsort_min ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_qsort_min xs <span class="fu">=</span> head (qsort xs) <span class="fu">==</span> minimum xs</code></pre></div>
<p>However, when we run this, we run into a glitch</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_qsort_min 
<span class="fu">***</span> <span class="dt">Failed</span><span class="fu">!</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="ch">'Prelude.head: empty list'</span> (after <span class="dv">1</span> test)<span class="fu">:</span>  
[]</code></pre></div>
<p>But of course! The earlier properties held <em>for all inputs</em> while this property makes no sense if the input list is empty! This is why thinking about specifications and properties has the benefit of clarifying the <em>preconditions</em> under which a given piece of code is supposed to work.</p>
<p>In this case we want a <em>conditional properties</em> where we only want the output to satisfy to satisfy the spec <em>if</em> the input meets the precondition that it is non-empty.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_qsort_nn_min    ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span>
<span class="ot">&gt;</span> prop_qsort_nn_min xs <span class="fu">=</span> 
<span class="ot">&gt;</span>   not (null xs) <span class="fu">==&gt;</span> head (qsort xs) <span class="fu">==</span> minimum xs
<span class="ot">&gt;</span> 
<span class="ot">&gt; prop_qsort_nn_max    ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span>
<span class="ot">&gt;</span> prop_qsort_nn_max xs <span class="fu">=</span> 
<span class="ot">&gt;</span>   not (null xs) <span class="fu">==&gt;</span> head (reverse (qsort xs)) <span class="fu">==</span> maximum xs</code></pre></div>
<p>We can write a similar property for the maximum element too. This time around, both the properties hold</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">1000</span> prop_qsort_nn_min
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">1000</span> tests<span class="fu">.</span>

ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">1000</span> prop_qsort_nn_max
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">1000</span> tests<span class="fu">.</span></code></pre></div>
<p>Note that now, instead of just being a <code>Bool</code> the output of the function is a <code>Property</code> a special type built into the QC library. Similarly the <em>implies</em> combinator <code>==&gt;</code> is on of many QC combinators that allow the construction of rich properties.</p>
<h2 id="testing-against-a-model-implementation">Testing Against a Model Implementation</h2>
<p>We could keep writing different properties that capture various aspects of the desired functionality of <code>qsort</code>. Another approach for validation is to test that our <code>qsort</code> is <em>behaviourally</em> identical to a trusted <em>reference implementation</em> which itself may be too inefficient or otherwise unsuitable for deployment. In this case, lets use the standard library’s <code>sort</code> function</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_qsort_sort    ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_qsort_sort xs <span class="fu">=</span>  qsort xs <span class="fu">==</span> sort xs</code></pre></div>
<p>which we can put to the test</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">1000</span> prop_qsort_sort
<span class="fu">***</span> <span class="dt">Failed</span><span class="fu">!</span> <span class="dt">Falsifiable</span> (after <span class="dv">4</span> tests and <span class="dv">1</span> shrink)<span class="fu">:</span>     
[<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">1</span>]</code></pre></div>
<p>Say, what?!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> qsort [<span class="fu">-</span><span class="dv">1</span>,<span class="fu">-</span><span class="dv">1</span>]
[<span class="fu">-</span><span class="dv">1</span>]</code></pre></div>
<p>Ugh! So close, and yet … Can you spot the bug in our code?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">qsort []     <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> qsort lhs <span class="fu">++</span> [x] <span class="fu">++</span> qsort rhs
  <span class="kw">where</span> lhs  <span class="fu">=</span> [y <span class="fu">|</span> y <span class="ot">&lt;-</span> xs, y <span class="fu">&lt;</span> x]
        rhs  <span class="fu">=</span> [z <span class="fu">|</span> z <span class="ot">&lt;-</span> xs, z <span class="fu">&gt;</span> x]</code></pre></div>
<p>We’re assuming that the <em>only</em> occurrence of (the value) <code>x</code> is itself! That is, if there are any <em>copies</em> of <code>x</code> in the tail, they will not appear in either <code>lhs</code> or <code>rhs</code> and hence they get thrown out of the output.</p>
<p>Is this a bug in the code? What <em>is</em> a bug anyway? Perhaps the fact that all duplicates are eliminated is a <em>feature</em>! At any rate there is an inconsistency between our mental model of how the code <em>should</em> behave as articulated in <code>prop_qsort_sort</code> and the actual behavior of the code itself.</p>
<p>We can rectify matters by stipulating that the <code>qsort</code> produces lists of distinct elements</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isDistinct ::</span>(<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isDistinct (x<span class="fu">:</span>xs) <span class="fu">=</span> not (x <span class="ot">`elem`</span> xs) <span class="fu">&amp;&amp;</span> isDistinct xs
<span class="ot">&gt;</span> isDistinct _      <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; prop_qsort_distinct ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span> 
<span class="ot">&gt;</span> prop_qsort_distinct <span class="fu">=</span> isDistinct <span class="fu">.</span> qsort  </code></pre></div>
<p>and then, weakening the equivalence to only hold on inputs that are duplicate-free</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_qsort_distinct_sort ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span> 
<span class="ot">&gt;</span> prop_qsort_distinct_sort xs <span class="fu">=</span> 
<span class="ot">&gt;</span>   (isDistinct xs) <span class="fu">==&gt;</span> (qsort xs <span class="fu">==</span> sort xs)</code></pre></div>
<p>QuickCheck happily checks the modified properties</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_qsort_distinct
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span>

ghci<span class="fu">&gt;</span> quickCheck prop_qsort_distinct_sort 
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">.</span></code></pre></div>
<h2 id="the-perils-of-conditional-testing">The Perils of Conditional Testing</h2>
<p>Well, we managed to <em>fix</em> the <code>qsort</code> property, but beware! Adding preconditions leads one down a slippery slope. In fact, if we paid closer attention to the above runs, we would notice something</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">10000</span> prop_qsort_distinct_sort 
<span class="fu">...</span>
(<span class="dv">5012</span> tests; <span class="dv">248</span> discarded)
<span class="fu">...</span>
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">10000</span> tests<span class="fu">.</span></code></pre></div>
<p>The bit about some tests being <em>discarded</em> is ominous. In effect, when the property is constructed with the <code>==&gt;</code> combinator, QC discards the randomly generated tests on which the precondition is false. In the above case QC grinds away on the remainder until it can meet its target of <code>10000</code> valid tests. This is because the probability of a randomly generated list meeting the precondition (having distinct elements) is high enough. This may not always be the case.</p>
<p>The following code is (a simplified version of) the <code>insert</code> function from the standard library</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">insert x []                 <span class="fu">=</span> [x]
insert x (y<span class="fu">:</span>ys) <span class="fu">|</span> x <span class="fu">&gt;</span> y     <span class="fu">=</span> x <span class="fu">:</span> y <span class="fu">:</span> ys
                <span class="fu">|</span> otherwise <span class="fu">=</span> y <span class="fu">:</span> insert x ys</code></pre></div>
<p>Given an element <code>x</code> and a list <code>xs</code>, the function walks along <code>xs</code> till it finds the first element greater than <code>x</code> and it places <code>x</code> to the left of that element. Thus</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> insert <span class="dv">8</span> ([<span class="dv">1</span><span class="fu">..</span><span class="dv">3</span>] <span class="fu">++</span> [<span class="dv">10</span><span class="fu">..</span><span class="dv">13</span>])
[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>]</code></pre></div>
<p>Indeed, the following is the well known <a href="http://en.wikipedia.org/wiki/Insertion_sort">insertion-sort</a> algorithm</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isort ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> isort <span class="fu">=</span> foldr insert []</code></pre></div>
<p>We could write our own tests, but why do something a machine can do better?!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_isort_sort    ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_isort_sort xs <span class="fu">=</span> isort xs <span class="fu">==</span> sort xs</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">10000</span> prop_isort_sort 
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">10000</span> tests<span class="fu">.</span></code></pre></div>
<p>Now, the reason that the above works is that the <code>insert</code> routine <em>preserves</em> sorted-ness. That is while of course the property</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_insert_ordered'      ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_insert_ordered' x xs <span class="fu">=</span> isOrdered (insert x xs)</code></pre></div>
<p>is bogus</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">10000</span> prop_insert_ordered' 
<span class="fu">***</span> <span class="dt">Failed</span><span class="fu">!</span> <span class="dt">Falsifiable</span> (after <span class="dv">4</span> tests and <span class="dv">1</span> shrink)<span class="fu">:</span>     
<span class="dv">0</span>
[<span class="dv">0</span>,<span class="fu">-</span><span class="dv">1</span>]

ghci<span class="fu">&gt;</span> insert <span class="dv">0</span> [<span class="dv">0</span>, <span class="fu">-</span><span class="dv">1</span>]
[<span class="dv">0</span>, <span class="dv">0</span>, <span class="fu">-</span><span class="dv">1</span>]</code></pre></div>
<p>the output <em>is</em> ordered if the input was ordered to begin with</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_insert_ordered      ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span> 
<span class="ot">&gt;</span> prop_insert_ordered x xs <span class="fu">=</span> 
<span class="ot">&gt;</span>   isOrdered xs <span class="fu">==&gt;</span> isOrdered (insert x xs)</code></pre></div>
<p>Notice that now, the precondition is more <em>complex</em> – the property requires that the input list be ordered. If we QC the property</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">10000</span> prop_insert_ordered
<span class="fu">***</span> <span class="dt">Gave</span> up<span class="fu">!</span> <span class="dt">Passed</span> only <span class="dv">35</span> tests<span class="fu">.</span></code></pre></div>
<p>Ugh! The ordered lists are so <em>sparsely</em> distributed among random lists, that QC timed out well before it found 10000 valid inputs!</p>
<p><em>Aside</em> the above example also illustrates the benefit of writing the property as <code>p ==&gt; q</code> instead of using the boolean operator <code>||</code> to write <code>not p || q</code>. In the latter case, there is a flat predicate, and QC doesn’t know what the precondition is, so a property may hold <em>vacuously</em>. For example consider the variant</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_insert_ordered_vacuous ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_insert_ordered_vacuous x xs <span class="fu">=</span> 
<span class="ot">&gt;</span>   not (isOrdered xs) <span class="fu">||</span> isOrdered (insert x xs)</code></pre></div>
<p>QC will happily check it for us</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheckN <span class="dv">1000</span> prop_insert_ordered_vacuous
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">10000</span> tests<span class="fu">.</span></code></pre></div>
<p>Unfortunately, in the above, the tests passed <em>vacuously</em> only because their inputs were <em>not</em> ordered, and one should use <code>==&gt;</code> to avoid the false sense of security delivered by vacuity.</p>
<p>QC provides us with some combinators for guarding against vacuity by allowing us to investigate the <em>distribution</em> of test cases</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">collect  ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span>
<span class="ot">classify ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Property</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></code></pre></div>
<p>We may use these to write a property that looks like</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_insert_ordered_vacuous' ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span> 
<span class="ot">&gt;</span> prop_insert_ordered_vacuous' x xs <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="co">-- collect (length xs) $</span>
<span class="ot">&gt;</span>   classify (isOrdered xs) <span class="st">&quot;ord&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   classify (not (isOrdered xs)) <span class="st">&quot;not-ord&quot;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>   not (isOrdered xs) <span class="fu">||</span> isOrdered (insert x xs)</code></pre></div>
<p>When we run this, as before we get a detailed breakdown of the 100 passing tests</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> quickCheck prop_insert_ordered_vacuous'
<span class="fu">+++</span> <span class="dt">OK</span>, passed <span class="dv">100</span> tests<span class="fu">:</span>
 <span class="dv">9</span><span class="fu">%</span> <span class="dv">1</span>, ord
 <span class="dv">2</span><span class="fu">%</span> <span class="dv">0</span>, ord
 <span class="dv">2</span><span class="fu">%</span> <span class="dv">2</span>, ord
 <span class="dv">5</span><span class="fu">%</span> <span class="dv">8</span>, not<span class="fu">-</span>ord
 <span class="dv">4</span><span class="fu">%</span> <span class="dv">7</span>, not<span class="fu">-</span>ord
 <span class="dv">4</span><span class="fu">%</span> <span class="dv">5</span>, not<span class="fu">-</span>ord
 <span class="fu">...</span></code></pre></div>
<p>where a line <code>P% N, COND</code> means that <code>p</code> percent of the inputs had length <code>N</code> and satisfied the predicate denoted by the string <code>COND</code>. Thus, as we see from the above, a paltry 13% of the tests were ordered and that was because they were either empty (<code>2% 0, ord</code>) or had one (<code>9% 1, ord</code>). or two elements (<code>2% 2, ord</code>). The odds of randomly stumbling upon a beefy list that is ordered are rather small indeed!</p>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
