<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - Type Based Verification using Liquid Haskell</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - Type Based Verification using Liquid Haskell </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
        <a href="../grades.html">Grading</a>
		<a href="../lectures.html">Lectures</a>
	    <a href="../assignments.html">Assignments</a>
	    <a href="../links.html">Links</a>
        <a href="https://piazza.com/class/i4kkvjdaoqj7aj#">Piazza</a>
        </div>
       
	<br />
	<br />
	<div class="hidden">
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">LectLiquid</span> <span class="kw">where</span>    
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Text.Unsafe</span> <span class="kw">as</span> <span class="dt">UT</span>    
<span class="ot">&gt;</span>     
<span class="ot">&gt;</span> <span class="co">{-@ type Nat = {n:Int | n &gt; 0} @-}</span>    
<span class="ot">&gt;</span> 
<span class="ot">&gt; notEmpty ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> notEmpty [] <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> notEmpty (_<span class="fu">:</span>_) <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>                  
<span class="ot">&gt;</span> <span class="co">{-@ measure notEmpty @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ type NEList a = {l:[a] | notEmpty l} @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ hd :: l:NEList a -&gt; a  @-}</span>
<span class="ot">&gt; hd ::</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> hd (x<span class="fu">:</span>xs) <span class="fu">=</span> x            
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">{-@ ex1 :: l:[NEList Char] -&gt; String @-}</span>
<span class="ot">&gt; ex1 ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> ex1 l <span class="fu">=</span> map hd l</code></pre></div>
</div>
<p>These lectures are based on this <a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/book.pdf">book</a> by the Liquid Haskell founders.</p>
<h1 id="haskell-can-be-unsafe">Haskell can be Unsafe</h1>
<p>Throughout this semester I have made the argument that Haskell’s type system make programming more correct, and more safe, by eliminating bugs at compiletime as opposed to runtime.</p>
<p>Haskell is indeed a step in the right direction, but it is still possible to do very unsafe things. First, one might think that it is not possible to obtain a segfault in Haskell, because of the type system, but this is just not true. Consider the following basic use of a function called <code>unsafeIndex :: Vector a -&gt; Int -&gt; a</code>:</p>
<pre class=".{haskell}"><code>ghci&gt; :m +Data.Vector
ghci&gt; let v = fromList [&quot;haskell&quot;, &quot;C#&quot;]
gchi&gt; unsafeIndex v 0
&quot;haskell&quot;
ghci&gt; unsafeIndex v 1
&quot;C#&quot;</code></pre>
<p>Now consider what happens when we ask for an index out of bounds:</p>
<pre class=".{haskell}"><code>ghci&gt; unsafeIndex v 10
'ghci' terminated by signal SIGSEGV ...</code></pre>
<p>Now this function <code>unsafeIndex</code> has <em>unsafe</em> in the name, but this shows that it possible to define a Haskell function that could cause a segfault.</p>
<p>What about reading past the edge of a memory buffer and returning bytes stored in memory unintentionally. This is excatly the main poin behind the heart-bleed exploit. Consider the following:</p>
<pre class=".{haskell}"><code>ghci&gt; :m + Data.Text Data.Text.Unsafe
ghci&gt; let t = pack &quot;Theory&quot;
ghci&gt; takeWord16 5 t
&quot;Theor&quot;
ghci&gt; takeWord16 100 t
&quot;Theory\NUL\NUL\9880\588\SOH\NUL\25392\2537\SOH\NUL\429108\SOH\NUL\NUL\NUL\NUL\NUL\ENQ\NUL\NUL\NUL\46792[\SOH\NUL\31515\835\SOH\NUL\53497\2100\SOH\NUL\741428\SOH\NUL\11868\24832\NUL\NUL\46792[\SOH\NUL\31515\835\SOH\NUL\53497\2100\SOH\NUL\757812\SOH\NUL\13156\24832\NUL\NUL\50168\637\SOH\NUL\774196\SOH\NUL\790580\SOH\NUL\33979\854\SOH\NUL\830516\SOH\NUL\17409\1652\SOH\NUL\17409\1652\SOH\NUL\41801\1552\SOH\NUL&quot;</code></pre>
<p>Notice that the final command above actually returns bytes stored in memory that are adjacent to <code>&quot;Theory&quot;</code>. These extra bytes could be junk, but they could also be passwords to bank accounts or other sensitive information.</p>
<p>These examples show that while Haskell is a step in the right direction, there is still more work that needs to be done.</p>
<h1 id="liquid-haskell-our-first-example">Liquid Haskell: Our First Example</h1>
<p>A real world example might be to use Liquid Haskell to prevent any misuse of the function <code>takeWord16</code> by refining its type. Now one might wonder why anyone would want to use this function knowing that is unsafe. Haskell allows one to drop down to the C level and provides many unsafe functions to allow the programmer to control efficiency.</p>
<p>We are going to define a safe version of <code>takeWord16</code> called <code>safeTakeWord16 :: Int -&gt; String -&gt; String</code>. To use Liquid Haskell to prevent any misuse of this we will refine its type so that the length of the input list must be at least the the first input of the function. That is, if we apply it like <code>safeTakeWord16 2 &quot;Liquid&quot;</code> then the program should type check using Liquid Haskell, but if we apply it like <code>safeTakeWord16 3 &quot;LH&quot;</code>, then we should expect a type error from Liquid Haskell.</p>
<p>The first thing we will do is define a new type called <code>SizedListLB a N</code> where <code>a</code> is the type of the elements of our new list, and <code>N</code> is the lower bound on the size each list is a allowed to have. Thus, <code>SizedListLB Char 5</code> is the type of all lists whose size is at least <code>5</code>. Thus, the list <code>['a','b','c','d','e']</code> has type <code>SizedListLB Char 5</code> while <code>[1,2]</code> does not have type <code>SizedListLB Int 4</code>.</p>
<p>We define our new type as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-@ type SizedListLB a N = {s:[a] | len s &gt;= N} @-}</span> </code></pre></div>
<p>Think of <code>len s</code> as the one true length of the list s, and it is built into Liquid Haskell.</p>
<p>Finally, using this new type we can refine <code>safeTakeWord16</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-@ safeTakeWord16 :: n:Int -&gt; SizedListLB Char n -&gt; String @-}</span>
<span class="ot">&gt; safeTakeWord16 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> safeTakeWord16 n s <span class="fu">=</span> <span class="kw">let</span> t <span class="fu">=</span> T.pack s
<span class="ot">&gt;</span>                       <span class="kw">in</span> show <span class="fu">$</span> UT.takeWord16 n t</code></pre></div>
<p>The benefit of all of this is that when we use <code>safeTakeWord</code> Liquid Haskell enforces that the input meets the refinement type. Thus, the following type checks:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ex2 ::</span> <span class="dt">String</span>
<span class="ot">&gt;</span> ex2 <span class="fu">=</span> safeTakeWord16 <span class="dv">2</span> <span class="st">&quot;Liquid&quot;</span></code></pre></div>
<p>However, the following does not type check:</p>
<pre class=".{haskell}"><code>ex3 :: String
ex3 = safeTakeWord16  100 &quot;Liquid&quot;</code></pre>
<h1 id="what-are-refinement-types-really">What are Refinement Types, Really?</h1>
<p>Refinement types can be seen as a pair of a logic predicate and a type. Logical predicates are constructed from a subset of boolean valued Haskell expressions. First, we have the following constants:</p>
<p><span class="math inline"><em>c</em> := 0 ∣ 1 ∣ 2 ∣ 3 ∣ ⋯</span></p>
<p>An expression <span class="math inline"><em>e</em></span> is then defined by the following grammar:</p>
<pre><code>e := x                 -- Variables
   | c                 -- Constants
   | e + e             -- Addition
   | e - e             -- Subtraction
   | c * e             -- Constant multiplication
   | x e1 e2 ... en    -- Variable application</code></pre>
<p>Next we define the valid relations:</p>
<pre><code>r := ==                -- equality
   | /=                -- disequality
   | &gt;=                -- greater than or equal
   | &lt;=                -- less than or equal
   | &gt;                 -- greater than
   | &lt;                 -- less than</code></pre>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
