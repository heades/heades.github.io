<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - The Locally-Nameless Binding Representation</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - The Locally-Nameless Binding Representation </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
	<a href="../lectures.html">Lectures</a>
	<a href="../links.html">Links</a>
        <a href="https://piazza.com/gru/fall2017/csci3300/home">Piazza</a>
        </div>
       
	<br />
	<br />
	<h1 id="de-bruijn-indices">De Bruijn Indices</h1>
<p>One of the hardest aspects of implementing programming languages is implementing binding constructs like <code>fun x =&gt; b</code> where <code>x</code> is bound in the program <code>b</code>. Consider the naive approach where we just use some naming device like strings or integers. Then we could implement syntax for functions and application as follows<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>:</p>
<div class="hidden">
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">{-@ LIQUID &quot;--short-names&quot; @-}</span>
<span class="ot">&gt;</span> <span class="co">{-@ LIQUID &quot;--no-termination&quot; @-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">LectLC</span> <span class="kw">where</span></code></pre></div>
</div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">NExp</span> <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="dt">VarN</span> <span class="dt">Name</span> 
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">FunN</span> <span class="dt">Name</span> <span class="dt">NExp</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">AppN</span> <span class="dt">NExp</span> <span class="dt">NExp</span>
<span class="ot">&gt;</span>   <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>However, consider an expression <code>FunN 0 (VarN 0)</code> how can we tell if <code>VarN 0</code> is free or bound? There is no way to tell. We might be able to get around this by saying, well, the binder has to match, but consider this expression <code>FunN 0 (FunN 0 (VarN 0))</code> now which binder does <code>VarN 0</code> belong to? There is no way to say. We could then say, well, associate it with the closest binder to the variable in the syntax tree. But, notice that all of this requires us to check external properties. Thus, code will be riddled with sanity checks. How can we instead build a data type that is more in line with enforcing these properties? This is the name of the binding implementation game. That is, how can we make it so that the syntax enforces the properties we want with as little development overhead as possible? Furthermore, can we develop our syntax to allow for mathematical reasoning about the properties of the PL we are implementing.</p>
<p>The earliest attempt to make implementing binding constructs a little less painful is called <em>De Bruijn Indices</em> due to the Dutch mathematician <a href="https://en.wikipedia.org/wiki/Nicolaas_Govert_de_Bruijn">Nicolaas Govert de Bruijn</a>. Names are integers in De Bruijn’s representation, but we use a particular pattern for keeping track of which variable is bound to which binder. To aid the reader first consider the data type of our syntax in De Bruijn’s representation:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">BExp</span> <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="dt">VarB</span> <span class="dt">Name</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">FunB</span> <span class="dt">BExp</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">AppB</span> <span class="dt">BExp</span> <span class="dt">BExp</span>
<span class="ot">&gt;</span>   <span class="kw">deriving</span> <span class="dt">Show</span>  </code></pre></div>
<p>Now, a <code>Name</code> is still an integer, and the syntax for variables did not change. However, notice that the <code>Name</code> on functions is now removed. This is the major contribution of this representation of syntax. But, you might be wondering how we associate a binder to a bound variable. De Bruijn came up with a naming scheme for bound variables. The name of a bound variable, in a program <code>b</code>, is equal to the one less than the number of binders it is below in <code>b</code>’s parse tree. For example, consider the following expressions:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; expB1 ::</span> <span class="dt">BExp</span>
<span class="ot">&gt;</span> expB1 <span class="fu">=</span> <span class="dt">FunB</span> (<span class="dt">VarB</span> <span class="dv">0</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; expB2 ::</span> <span class="dt">BExp</span>
<span class="ot">&gt;</span> expB2 <span class="fu">=</span> <span class="dt">FunB</span> (<span class="dt">AppB</span> (<span class="dt">FunB</span> (<span class="dt">VarB</span> <span class="dv">1</span>)) (<span class="dt">VarB</span> <span class="dv">0</span>))
<span class="ot">&gt;</span> 
<span class="ot">&gt; expB3 ::</span> <span class="dt">BExp</span>
<span class="ot">&gt;</span> expB3 <span class="fu">=</span> <span class="dt">AppB</span> (<span class="dt">FunB</span> (<span class="dt">FunB</span> (<span class="dt">AppB</span> (<span class="dt">VarB</span> <span class="dv">0</span>) (<span class="dt">VarB</span> <span class="dv">1</span>)))) (<span class="dt">VarB</span> <span class="dv">2</span>)</code></pre></div>
<p>Using this scheme it is always possible to decide which variable is associated with which binder. However, notice that it is relatively hard to decide which variables are free and which are bound. This is where locally-nameless representation comes into play.</p>
<h1 id="locally-nameless-representation-lnr">Locally-Nameless Representation (LNR)</h1>
<p>LNR splits the variable constructor into two constructors <code>Fvar Name</code> and <code>Bvar Name</code> where the former is the constructor for free variables, and the later is the constructor for bound variables. De Bruin indices are then used for the naming scheme for bound variables, but there is no naming scheme for free variables.</p>
<p>The following is the datatype of expressions for Functional Iffy using LNR:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="dt">Fvar</span> <span class="dt">Name</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">Bvar</span> <span class="dt">Name</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">T</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">F</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">And</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">Or</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">If</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">Fun</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>   <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>   <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
Here are some examples:
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; exLC1 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> exLC1 <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">Fun</span> (<span class="dt">And</span> (<span class="dt">Bvar</span> <span class="dv">0</span>) (<span class="dt">Fvar</span> <span class="dv">0</span>))) (<span class="dt">Fun</span> (<span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">0</span>)))
<span class="ot">&gt;</span> 
<span class="ot">&gt; exLC2 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> exLC2 <span class="fu">=</span> <span class="dt">And</span> <span class="dt">T</span> (<span class="dt">Fvar</span> <span class="dv">42</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; exLC3 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> exLC3 <span class="fu">=</span> <span class="dt">Fun</span> (<span class="dt">If</span> (<span class="dt">Bvar</span> <span class="dv">0</span>) (<span class="dt">Fun</span> (<span class="dt">And</span> (<span class="dt">Bvar</span> <span class="dv">1</span>) (<span class="dt">App</span> (<span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">3</span>)) <span class="dt">T</span>))) (<span class="dt">Fvar</span> <span class="dv">21</span>))</code></pre></div>
Here are a few non-examples:
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; nexLC1 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> nexLC1 <span class="fu">=</span> <span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">1</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; nexLC2 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> nexLC2 <span class="fu">=</span> <span class="dt">Bvar</span> <span class="dv">0</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; nexLC3 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> nexLC3 <span class="fu">=</span> <span class="dt">Fun</span> (<span class="dt">If</span> (<span class="dt">Bvar</span> <span class="dv">1</span>) (<span class="dt">Fun</span> (<span class="dt">And</span> (<span class="dt">Bvar</span> <span class="dv">2</span>) (<span class="dt">App</span> (<span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">4</span>)) <span class="dt">T</span>))) (<span class="dt">Fvar</span> <span class="dv">21</span>))</code></pre></div>
<p>Notice that <code>nexLC3</code> is <code>exLC3</code> with the indices all incrementated.</p>
<h2 id="opening-and-closing">Opening and Closing</h2>
<p>The <span class="math inline"><em>β</em></span>-rule states that we can evaluate <span class="math inline"><em>a</em><em>p</em><em>p</em> (fun <em>x</em>  ⇒ <em>b</em>2) <em>b</em>1</span> to <span class="math inline">[<em>b</em>1/<em>x</em>]<em>b</em>2</span>. The first thing this rule does is go from <span class="math inline">fun <em>x</em>  ⇒ <em>b</em>2</span> to <span class="math inline"><em>b</em>2</span>, which implicitly transforms <span class="math inline"><em>x</em></span> from a bound variable into a free variable. Consider the same situation using LNR. We can model <span class="math inline">fun <em>x</em>  ⇒ <em>b</em>2</span> by <code>Fun b2</code> where <span class="math inline"><em>x</em></span> is <code>Bvar i</code>. Then when we go from <code>Fun b2</code> to <code>b2</code> the variable <code>Bvar i</code> becomes a free-bound variable, and thus, is not replaceable via substitution. When we rip off a binder we need an operation that converts a free-bound variable into an actual free variable. This operation is called opening an expression.</p>
<p>Opening an expression converts a free-bound variable into a free variable:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; open ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> open x b <span class="fu">=</span> open' x <span class="dv">0</span> b
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;   open' ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>   open' x y b<span class="fu">@</span>(<span class="dt">Bvar</span> z) <span class="fu">|</span> y <span class="fu">==</span> z <span class="fu">=</span> <span class="dt">Fvar</span> x
<span class="ot">&gt;</span>                        <span class="fu">|</span> otherwise <span class="fu">=</span> b
<span class="ot">&gt;</span>   open' x y (<span class="dt">Fun</span> b) <span class="fu">=</span> <span class="dt">Fun</span> (open' x (y<span class="fu">+</span><span class="dv">1</span>) b)
<span class="ot">&gt;</span>   open' x y (<span class="dt">And</span> b1 b2) <span class="fu">=</span> <span class="dt">And</span> (open' x y b1) (open' x y b2)
<span class="ot">&gt;</span>   open' x y (<span class="dt">Or</span> b1 b2) <span class="fu">=</span> <span class="dt">Or</span> (open' x y b1) (open' x y b2)
<span class="ot">&gt;</span>   open' x y (<span class="dt">App</span> b1 b2) <span class="fu">=</span> <span class="dt">App</span> (open' x y b1) (open' x y b2)
<span class="ot">&gt;</span>   open' x y (<span class="dt">If</span> b1 b2 b3) <span class="fu">=</span> <span class="dt">If</span> (open' x y b1) (open' x y b2) (open' x y b3)                   
<span class="ot">&gt;</span>   open' x y b <span class="fu">=</span> b</code></pre></div>
<p>This definition implies that in the application <code>open x b</code> the first argument, <code>x</code>, is the name of the new free variable, the second argument, <code>b</code>, is the program we are opening. Notice that this definition does indeed prevent one from replacing a bound variable that is associated with a binder:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; openEX ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> openEX <span class="fu">=</span> open <span class="dv">0</span> (<span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">0</span>))</code></pre></div>
<p>The previous expression evaluates to <code>Fun (Bvar 0)</code> and not <code>Fun (Fvar 0)</code>, thus, the openly bound variables that <code>open</code> will replace are indeed free-bound variables.</p>
<p>Closing is the dual operation. It replaces a free variable with a bound variable. Keep in mind that in the bound variable that replaces the free variable must be labeled with the number of abstractions we pass to reach that variable. Thus, the recursive definition is similar to that of <code>open</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; close ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> close x b <span class="fu">=</span> close' <span class="dv">0</span> x b
<span class="ot">&gt;</span>  <span class="kw">where</span>            
<span class="ot">&gt;    close' ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>    close' x y b<span class="fu">@</span>(<span class="dt">Fvar</span> z) <span class="fu">|</span> y <span class="fu">==</span> z <span class="fu">=</span> <span class="dt">Bvar</span> x
<span class="ot">&gt;</span>                          <span class="fu">|</span> otherwise <span class="fu">=</span> b
<span class="ot">&gt;</span>    close' x y (<span class="dt">Fun</span> b) <span class="fu">=</span> <span class="dt">Fun</span> (close' x (y<span class="fu">+</span><span class="dv">1</span>) b)
<span class="ot">&gt;</span>    close' x y (<span class="dt">And</span> b1 b2) <span class="fu">=</span> <span class="dt">And</span> (close' x y b1) (close' x y b2)
<span class="ot">&gt;</span>    close' x y (<span class="dt">Or</span> b1 b2) <span class="fu">=</span> <span class="dt">Or</span> (close' x y b1) (close' x y b2)
<span class="ot">&gt;</span>    close' x y (<span class="dt">App</span> b1 b2) <span class="fu">=</span> <span class="dt">App</span> (close' x y b1) (close' x y b2)
<span class="ot">&gt;</span>    close' x y (<span class="dt">If</span> b1 b2 b3) <span class="fu">=</span> <span class="dt">If</span> (close' x y b1) (close' x y b2) (close' x y b3)                   
<span class="ot">&gt;</span>    close' x y b <span class="fu">=</span> b</code></pre></div>
<h2 id="local-closure">Local Closure</h2>
<p>The only property of expressions we must check externally is that there are no free-bound variables. The datatype does not enforce this internally. We call a program <em>locally-closed</em> if and only if it contains no free-bound variables. We now will define a function, <code>lc :: Exp -&gt; Bool</code> that captures this property. However, before we can define <code>lc</code> we first must define a means of generating a fresh free variable.</p>
<p>The following function computes the list of free variables in its argument.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fv ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]
<span class="ot">&gt;</span> fv (<span class="dt">Fvar</span> x) <span class="fu">=</span> [x]
<span class="ot">&gt;</span> fv (<span class="dt">Fun</span> b) <span class="fu">=</span> fv b
<span class="ot">&gt;</span> fv (<span class="dt">And</span> b1 b2) <span class="fu">=</span> (fv b1) <span class="fu">++</span> (fv b2)
<span class="ot">&gt;</span> fv (<span class="dt">Or</span> b1 b2) <span class="fu">=</span> (fv b1) <span class="fu">++</span> (fv b2)
<span class="ot">&gt;</span> fv (<span class="dt">App</span> b1 b2) <span class="fu">=</span> (fv b1) <span class="fu">++</span> (fv b2)
<span class="ot">&gt;</span> fv (<span class="dt">If</span> b1 b2 b3) <span class="fu">=</span> (fv b1) <span class="fu">++</span> (fv b2) <span class="fu">++</span> (fv b3)
<span class="ot">&gt;</span> fv _ <span class="fu">=</span> []</code></pre></div>
<p>The previous function follows exactly the definition developed in the theory section. Using this we define <code>freshFV :: Exp -&gt; Name</code> that will generate a fresh free variable name with respect to the free variables in its argument by first computing the list of free variables, and then adding one to the maximum label.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; freshFV ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Name</span>
<span class="ot">&gt;</span> freshFV b <span class="fu">=</span> <span class="kw">let</span> fvars <span class="fu">=</span> fv b
<span class="ot">&gt;</span>              <span class="kw">in</span> <span class="kw">case</span> fvars <span class="kw">of</span>
<span class="ot">&gt;</span>                   [] <span class="ot">-&gt;</span> <span class="dv">0</span>
<span class="ot">&gt;</span>                   _ <span class="ot">-&gt;</span> fresh fvars
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;    fresh ::</span> [<span class="dt">Name</span>] <span class="ot">-&gt;</span> <span class="dt">Name</span>
<span class="ot">&gt;</span>    fresh n <span class="fu">=</span> (maximum n) <span class="fu">+</span> <span class="dv">1</span></code></pre></div>
<p>Finally, we use <code>freshFV</code> to define the local-closure predicate:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; lc ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> lc (<span class="dt">Bvar</span> _) <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> lc (<span class="dt">Fun</span> b) <span class="fu">=</span> lc (open x b)
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;</span>    x <span class="fu">=</span> freshFV b
<span class="ot">&gt;</span> lc (<span class="dt">And</span> b1 b2) <span class="fu">=</span> (lc b1) <span class="fu">&amp;&amp;</span> (lc b2)
<span class="ot">&gt;</span> lc (<span class="dt">Or</span> b1 b2) <span class="fu">=</span> (lc b1) <span class="fu">&amp;&amp;</span> (lc b2)
<span class="ot">&gt;</span> lc (<span class="dt">App</span> b1 b2) <span class="fu">=</span> (lc b1) <span class="fu">&amp;&amp;</span> (lc b2)
<span class="ot">&gt;</span> lc (<span class="dt">If</span> b1 b2 b3) <span class="fu">=</span> (lc b1) <span class="fu">&amp;&amp;</span> (lc b2) <span class="fu">&amp;&amp;</span> (lc b3)       
<span class="ot">&gt;</span> lc _ <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>The take away from this definition is that to test local closure of <code>Fun b</code> we rip off the binder, and open <code>b</code>. This eliminates the bound variable associated with that binder, and thus, if we keep eliminating bound variables, then we should eventually reach a program with only free variables left. If this does not happen, then we know the input is not locally closed. In addition, notice that when we open <code>b</code> we generate a fresh variable.</p>
<h2 id="the-evaluator">The Evaluator</h2>
<p>At last we have reached the pinnacle of this section the evaluator. First, we need capture-avoiding substitution. This actually has a straightforward definition:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; subst ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> subst b x b'<span class="fu">@</span>(<span class="dt">Fvar</span> y) <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> b
<span class="ot">&gt;</span>                       <span class="fu">|</span> otherwise <span class="fu">=</span> b'
<span class="ot">&gt;</span> subst b x (<span class="dt">Fun</span> b') <span class="fu">=</span> <span class="dt">Fun</span> (subst b x b')
<span class="ot">&gt;</span> subst b x (<span class="dt">App</span> b1 b2) <span class="fu">=</span> <span class="dt">App</span> (subst b x b1) (subst b x b2)
<span class="ot">&gt;</span> subst b x (<span class="dt">And</span> b1 b2) <span class="fu">=</span> <span class="dt">And</span> (subst b x b1) (subst b x b2)
<span class="ot">&gt;</span> subst b x (<span class="dt">Or</span> b1 b2) <span class="fu">=</span> <span class="dt">Or</span> (subst b x b1) (subst b x b2)
<span class="ot">&gt;</span> subst b x (<span class="dt">If</span> b1 b2 b3) <span class="fu">=</span> <span class="dt">If</span> (subst b x b1) (subst b x b2) (subst b x b3)
<span class="ot">&gt;</span> subst b x b' <span class="fu">=</span> b'</code></pre></div>
<p>Notice that if the input of <code>subst</code> is locally closed, then it is capture avoiding by definition, because the only way for a binder to capture a variable is if the variable is a <code>Bvar</code>, and hence, since the input is locally closed, then this cannot be the case. In fact, we have the following result:</p>
<p>If <code>lc(b1)</code> and <code>lc(b2)</code>, then <code>lc(subst b1 x b2)</code> for any <code>x</code>.</p>
<p>Thus, to prevent capture simply restrict oneself to the locally-closed expressions.</p>
Finally, we have the evaluator:
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; eval' ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> eval' (<span class="dt">Fun</span> b) <span class="fu">=</span> <span class="dt">Fun</span> <span class="fu">$</span> eval' b            
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> eval' (<span class="dt">App</span> b1 b2) <span class="fu">=</span> <span class="kw">case</span> v1 <span class="kw">of</span>
<span class="ot">&gt;</span>                      (<span class="dt">Fun</span> v) <span class="ot">-&gt;</span> <span class="kw">let</span> fvar <span class="fu">=</span> freshFV v
<span class="ot">&gt;</span>                                  <span class="kw">in</span> eval' <span class="fu">$</span> subst v2 fvar <span class="fu">$</span> open fvar v
<span class="ot">&gt;</span>                      _ <span class="ot">-&gt;</span> <span class="dt">App</span> v1 v2
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;</span>    v1 <span class="fu">=</span> eval' b1
<span class="ot">&gt;</span>    v2 <span class="fu">=</span> eval' b2
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> eval' (<span class="dt">And</span> e1 e2) <span class="fu">=</span> <span class="kw">case</span> (v1,v2) <span class="kw">of</span>
<span class="ot">&gt;</span>                      (<span class="dt">T</span>,<span class="dt">T</span>) <span class="ot">-&gt;</span> <span class="dt">T</span>
<span class="ot">&gt;</span>                      (<span class="dt">F</span>,<span class="dt">T</span>) <span class="ot">-&gt;</span> <span class="dt">F</span>
<span class="ot">&gt;</span>                      (<span class="dt">T</span>,<span class="dt">F</span>) <span class="ot">-&gt;</span> <span class="dt">F</span>
<span class="ot">&gt;</span>                      (<span class="dt">F</span>,<span class="dt">F</span>) <span class="ot">-&gt;</span> <span class="dt">F</span>
<span class="ot">&gt;</span>                      (_,_) <span class="ot">-&gt;</span> <span class="dt">And</span> v1 v2
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;</span>    v1 <span class="fu">=</span> eval' e1
<span class="ot">&gt;</span>    v2 <span class="fu">=</span> eval' e2
<span class="ot">&gt;</span>         
<span class="ot">&gt;</span> eval' (<span class="dt">Or</span> e1 e2) <span class="fu">=</span> <span class="kw">case</span> (v1,v2) <span class="kw">of</span>
<span class="ot">&gt;</span>                      (<span class="dt">T</span>,<span class="dt">T</span>) <span class="ot">-&gt;</span> <span class="dt">T</span>
<span class="ot">&gt;</span>                      (<span class="dt">F</span>,<span class="dt">T</span>) <span class="ot">-&gt;</span> <span class="dt">T</span>
<span class="ot">&gt;</span>                      (<span class="dt">T</span>,<span class="dt">F</span>) <span class="ot">-&gt;</span> <span class="dt">T</span>
<span class="ot">&gt;</span>                      (<span class="dt">F</span>,<span class="dt">F</span>) <span class="ot">-&gt;</span> <span class="dt">F</span>
<span class="ot">&gt;</span>                      (_,_) <span class="ot">-&gt;</span> <span class="dt">Or</span> v1 v2
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;</span>    v1 <span class="fu">=</span> eval' e1
<span class="ot">&gt;</span>    v2 <span class="fu">=</span> eval' e2
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> eval' (<span class="dt">If</span> e1 e2 e3) <span class="fu">=</span> <span class="kw">case</span> v1 <span class="kw">of</span>
<span class="ot">&gt;</span>                        <span class="dt">T</span> <span class="ot">-&gt;</span> v2
<span class="ot">&gt;</span>                        <span class="dt">F</span> <span class="ot">-&gt;</span> v3
<span class="ot">&gt;</span>                        _ <span class="ot">-&gt;</span> <span class="dt">If</span> v1 v2 v3
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;</span>    v1 <span class="fu">=</span> eval' e1
<span class="ot">&gt;</span>    v2 <span class="fu">=</span> eval' e2
<span class="ot">&gt;</span>    v3 <span class="fu">=</span> eval' e3
<span class="ot">&gt;</span>    
<span class="ot">&gt;</span> eval' b <span class="fu">=</span> b
<span class="ot">&gt;</span> 
<span class="ot">&gt; eval ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> eval b <span class="fu">|</span> lc b <span class="fu">=</span> eval' b
<span class="ot">&gt;</span>        <span class="fu">|</span> otherwise <span class="fu">=</span> error <span class="st">&quot;Input to eval is not locally closed.&quot;</span>              </code></pre></div>
<p>The most interesting case of the evaluators definition is function application. In this case we first evaluate the arguments to <code>App</code>, and then we decide if the first is a function or not, and if it is, then we apply the <span class="math inline"><em>β</em></span>-rule. To <span class="math inline"><em>β</em></span>-contract we first, rip off the binder, open the body of the function with a fresh-free variable, and then do the substitution. The remainder of the cases are straightforward. Lastly, notice that we check for local closure in <code>eval</code> before evaluating. This prevents any type of capture.</p>
<p>The following are several examples:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; evalTest1 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> evalTest1 <span class="fu">=</span> eval <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">0</span>)) <span class="dt">T</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; evalTest2 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> evalTest2 <span class="fu">=</span> eval <span class="fu">$</span> <span class="dt">And</span> <span class="dt">T</span> <span class="fu">$</span> <span class="dt">Or</span> <span class="dt">F</span> <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Fun</span> (<span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">1</span>))) <span class="dt">T</span>) <span class="dt">T</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; evalLoop ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> evalLoop <span class="fu">=</span> <span class="kw">let</span> l <span class="fu">=</span> (<span class="dt">Fun</span> (<span class="dt">App</span> (<span class="dt">Bvar</span> <span class="dv">0</span>) (<span class="dt">Bvar</span> <span class="dv">0</span>)))
<span class="ot">&gt;</span>             <span class="kw">in</span> eval <span class="fu">$</span> <span class="dt">App</span> l l
<span class="ot">&gt;</span> 
<span class="ot">&gt; evalTest3 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> evalTest3 <span class="fu">=</span> eval <span class="fu">$</span> <span class="dt">Or</span> (<span class="dt">Fvar</span> <span class="dv">0</span>) <span class="dt">T</span>                
<span class="ot">&gt;</span> 
<span class="ot">&gt; evalTest4 ::</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span> evalTest4 <span class="fu">=</span> eval <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">Fun</span> (<span class="dt">Bvar</span> <span class="dv">1</span>)) <span class="dt">T</span>   </code></pre></div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>We append <code>N</code> to each to each constructor, because this file is a <a href="https://wiki.haskell.org/Literate_programming">Literate Haskell</a> file that can be interpreted by GHCi, and thus, the data types we implement in this post all must be distinct.<a href="#fnref1">↩</a></p></li>
</ol>
</div>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
