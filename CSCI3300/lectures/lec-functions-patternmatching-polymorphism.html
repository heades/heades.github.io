<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - Functions, Pattern Matching, and Polymorphism</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - Functions, Pattern Matching, and Polymorphism </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
	<a href="../lectures.html">Lectures</a>
	<a href="../links.html">Links</a>
        <a href="https://piazza.com/gru/fall2016/csci3300/home">Piazza</a>
        </div>
       
	<br />
	<br />
	<div class="hidden">
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">LectFuns</span> <span class="kw">where</span></code></pre></div>
</div>
<h2 id="functions">Functions</h2>
<p>In C# the predominant way to structure programs is by using objects and methods. Haskell is a bit different which uses <em>functions</em> to structure programs. Now do not think this means that Haskell lacks in the ability to structure large programs, because as we will see throughout the semester structuring programs using functions is very powerful.</p>
<p>Throughout this section we will design a prime number generator which will require the construction of a number of functions. The general layout of a function in Haskell is as follows:</p>
<pre class=".(haskell)"><code>name :: a1 -&gt; a2 -&gt; ... -&gt; ai -&gt; b
name x1 x2 ... xi = y</code></pre>
<p>Here the type of <code>x1</code> is <code>a1</code>, the type of <code>x2</code> is <code>a2</code>, and so on until the type of <code>xi</code> is <code>ai</code>, and finally, the type of <code>y</code> is <code>b</code>.</p>
<p>For example, here is the divides function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; divides ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> divides d n <span class="fu">=</span> rem n d <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>This function takes in two integers, and returns <code>True</code> when <code>n</code> divided by <code>d</code> has a remainder of <code>0</code>. Here the function <code>rem</code> is the remainder function which is equivalent to <code>n % d</code> in C#. For example,</p>
<pre class=".(haskell)"><code>ghci&gt; divides 2 6
True
ghci&gt; divides 3 12
True
ghci&gt; divides 4 9
False</code></pre>
<h2 id="guards">Guards</h2>
<p>The next step of our prime number test is to define a means of computing the least divisor of a number <code>n</code> that is greater than <code>1</code>. The algorithm is a bit eaiser if we define it in terms of one that computes the least divisor of <code>n</code> greater than or equal to a threshold <code>k</code>. The algorithm is as follows:</p>
<ol style="list-style-type: decimal">
<li>If <code>divides k n</code>, then <code>ldf k n = k</code></li>
<li>If <code>k^2 &gt; n</code>, then <code>ldf k n = n</code></li>
<li>Otherwise <code>ldf k n = ldf (k+1) n</code></li>
</ol>
<p>So we need to find a way to write a function which uses a condition, and a means of doing recursion, because the previous description calls <code>ldf</code> again in the result.</p>
<p>There are two ways to define <code>ldf</code>. The first way is as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ldf1 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ldf1 k n <span class="fu">=</span> <span class="kw">if</span> (divides k n)
<span class="ot">&gt;</span>            <span class="kw">then</span> k
<span class="ot">&gt;</span>            <span class="kw">else</span> <span class="kw">if</span> (k<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> n)
<span class="ot">&gt;</span>                 <span class="kw">then</span> n
<span class="ot">&gt;</span>                 <span class="kw">else</span> ldf1 (k<span class="fu">+</span><span class="dv">1</span>) n</code></pre></div>
<p>This function definition uses the if-then-else expression <code>if b then e1 else e2</code> where <code>b</code> is a boolean, <code>e1</code> has some type <code>a</code>, and <code>e2</code> has the same type <code>a</code>.</p>
<p>However, there is a better way using what are called <em>guards</em>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ldf ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> divides k n <span class="fu">=</span> k
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> k<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> n <span class="fu">=</span> n
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> otherwise <span class="fu">=</span> ldf1 (k<span class="fu">+</span><span class="dv">1</span>) n</code></pre></div>
<p>This is called a <em>guarded equation</em> which has the general form:</p>
<pre class=".(haskell)"><code>name x1 x2 ... xi | b1 = y1
name x1 x2 ... xi | b2 = y2
name x1 x2 ... xi | b3 = y3
name x1 x2 ... xi | b4 = y4
...
name x1 x2 ... xi | otherwise = yj</code></pre>
<p>Each of the <code>x1 ... xi</code> are the arguments to the function, and each <code>b1 ... bj</code> are booleans and are called <em>guards</em>. Finally, each of <code>y1 ... yj</code> are the respective bodies of the function. Ghci evaluates this function by starting at the first equation, and determining if <code>b1</code> is true, if it is, then the function returns <code>y1</code>, but if it is false, then Haskell movies on to the second equation and determines if <code>b2</code> is true, and if it is, then returns <code>y2</code>, and so on. Notice that the guard in the last equation is <code>otherwise</code>, this is the “catch-all” case. That is, it is exactly like <code>else</code> in an if-then-else expression, and thus, if all the guards on the previous equations are false, then this equation is chosen.</p>
<p>So consider <code>ldf 7 24</code>. First, ghci checks to see if <code>divides 7 24</code> is true, but it is false, and so abandons that equation and moves onto the second one, and asks if <code>k^2 &gt; n</code>, and it is, and so <code>ldf 7 24 = 24</code>.</p>
<p>As a second example, consider <code>ldf 7 2224</code>. Notice that <code>7</code> does not divide <code>2224</code>, nor is <code>7^2 &gt; 2224</code>, and thus, the equation ghci runs is the third equation, because that is the catch-all case. Thus, <code>ldf 7 2224 = ldf (7+1) 2224 = ldf 8 2224</code>. In this branch we make a recursive call which increases the first argument by one. Finally, we can see that <code>divides 8 2224</code> is true, and hence, <code>ldf 7 2224 = ldf 8 2224 = 8</code>.</p>
<p>Note that in Haskell doing recursive calls is easy, because we can simply call the function again within the body of the function. This is just like mathematics! In this class all functions we define must be terminating, and thus, one must make sure that when making a recursive call to increase or decrease at least one argument to the function, so that it tends towards the base cases. In <code>ldf</code> we increase by one, because we know from algebra that it is a property of the least divisor function that we will eventually find the least divisor greater than <code>k</code>.</p>
<p>Using <code>ldf</code> we can define the least common divisor function as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ld ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ld n <span class="fu">=</span> ldf <span class="dv">2</span> n</code></pre></div>
<p>Here are a few examples:</p>
<pre class=".(haskell)"><code>ghci&gt; ld 14
2
ghci&gt; ld 15
3
ghci&gt; ld 16
2
ghci&gt; ld 55
5</code></pre>
<p>At this point we have everything we need to define a prime number test.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> isPrime n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">1</span> <span class="fu">=</span> error <span class="st">&quot;not a positive integer&quot;</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">1</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> otherwise <span class="fu">=</span> ld n <span class="fu">==</span> n</code></pre></div>
<p>In the definition of <code>isPrime</code> we used a bit a simplified form of the guards. This definition is equivalent to the following one:</p>
<pre class=".(haskell)"><code>isPrime n | n &lt; 1 = error &quot;not a positive integer&quot;
isPrime n | n == 1 = False
isPrime n | otherwise = ld n == n</code></pre>
<p>The <code>error</code> function tells Haskell to throw an exception and output its argument to STDOUT – the screen – the message. For example,</p>
<pre class=".(haskell)"><code>ghci&gt; isPrime (-1)
** Exception: not a positive integer
CallStack (from HasCallStack):
  error, called at lectures/lec-functions-patternmatching-polymorphism.lhs:164:21 in main:LectFuns
ghci&gt; </code></pre>
<p>Keep in mind that this exception cannot be caught, and it causes the current execution to be terminated.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>There is one extremely powerful tool Haskell – as well as many other functional programming languages – provides called <em>pattern matching</em>. This allows one to case split on the shape of a data type. First, we will concentrate on pattern matching on input arguments, and then discuss a more general form which allows for one to case split on the outputs of function calls.</p>
<p>We begin with an example. Suppose we wished to define disjunction over the booleans. One way would be to use guards:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or1 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or1 b1 b2 <span class="fu">|</span> b1 <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> b2 <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>This works, but consider a second way:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or2 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or2 <span class="dt">True</span> b2 <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> or2 b1 <span class="dt">True</span> <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> or2 b1 b2 <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>The function <code>or2</code> uses pattern matching on the input arguments by enforcing when either <code>b1</code> or <code>b2</code> are <code>True</code>. Consider the first equation of <code>or2</code>, this equation states that <code>b1</code> must be <code>True</code>, and if during evaluation it is not, then Haskell will move on to the next equation where it will check to see if <code>b2</code> is <code>True</code>. In the second equation, <code>b1</code> means that the first argument can be either <code>True</code> or <code>False</code>, but if during evaluation this argument is chosen, then it is necessarily the case that <code>b1</code> is <code>False</code>, or the first equation would have triggered. Finally, if during evaluation the third equation is chosen, then both inputs must be <code>False</code>.</p>
<p>Haskell’s evaluation strategy is called “call-by-need evaluation.” This means that Haskell will only evaluate a program when it needs its value and in all other cases it will leave the program completely unevaluated. Consider as an example the following two functions:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; foo ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> foo <span class="dv">0</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> foo n <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; bar ::</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> bar <span class="fu">=</span> or2 <span class="dt">True</span> (foo <span class="dv">5</span>)</code></pre></div>
<p>When evaluating <code>bar</code> Haskell will evaluate as little as possible to determine the output of <code>or2</code>, and hence, since the first argument is <code>True</code> Haskell does not have to evaluate <code>foo 5</code> at all, and in fact, it does not evaluate it, and simply returns <code>True</code>, because that is all it needs to determine the correct output. This style of evaluation is often called <em>lazy evaluation</em> for obvious reasons.</p>
<p>Here is a third way to define this function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or3 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or3 <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> or3 b1 b2 <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>In this version we use pattern matching to determine when the function should be <code>False</code>, and then leave the catch-all case to handle when it should return <code>True</code>.</p>
<p>We can simplfy this function one last time:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or4 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or4 <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> or4 _ _ <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>Notice that in the definition of <code>or3</code> the second equation does not use the variables <code>b1</code> and <code>b2</code> in the body of the function. This new definition tells Haskell to ignore those inputs completely, because we are not going to use them. The <code>_</code> is called the “joker”. It can be read as “I don’t care what this argument is, in fact, I am not even going to use it.”</p>
<p>Booleans are fun, but they do not have a lot of structure, and so it is hard to see just how powerful pattern matching is. Recall that every list <code>[x1,x2,x3,...,xi]</code> is just syntactic sugar for the list <code>x1 : x2 : x3 : ... : xi : []</code>. In addition, both of the previous lists are equivalent to <code>x1:[x2,x3,...,xi]</code>. It turns out that the latter form can be used to pattern match on lists.</p>
<p>Consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; firstInt ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> firstInt [] <span class="fu">=</span> error <span class="st">&quot;empty list has no first integer&quot;</span>
<span class="ot">&gt;</span> firstInt (i<span class="fu">:</span>rest) <span class="fu">=</span> i</code></pre></div>
<p>We know that either a list is empty or it has at least one element inside of it. The first equation in <code>firstInt</code> checks to see if the input list is empty, and if so, outputs an error. If during evaluation the second equation is hit, then we know that the list cannot be empty, because Haskell starts with the first equation and moves downward until it matches the pattern. The pattern <code>i:rest</code> tells Haskell to name the first element of the input list <code>i</code>, and the to name the remainder of the list <code>rest</code>. For example, suppose we applied <code>firstInt</code> to the list <code>[1,2,3]</code>, then we know that this list is equivalent to the list <code>1:[2,3]</code>. Haskell will then name <code>1</code> <code>i</code>, and the list <code>[2,3]</code> <code>rest</code>.</p>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
