<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - Functions, Pattern Matching, and Polymorphism</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - Functions, Pattern Matching, and Polymorphism </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
	<a href="../lectures.html">Lectures</a>
	<a href="../links.html">Links</a>
        <a href="https://piazza.com/gru/fall2016/csci3300/home">Piazza</a>
        </div>
       
	<br />
	<br />
	<div class="hidden">
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">LectFuns</span> <span class="kw">where</span></code></pre></div>
</div>
<h2 id="functions">Functions</h2>
<p>In C# the predominant way to structure programs is by using objects and methods. Haskell is a bit different which uses <em>functions</em> to structure programs. Now do not think this means that Haskell lacks in the ability to structure large programs, because as we will see throughout the semester structuring programs using functions is very powerful.</p>
<p>Throughout this section we will design a prime number generator which will require the construction of a number of functions. The general layout of a function in Haskell is as follows:</p>
<pre class=".(haskell)"><code>name :: a1 -&gt; a2 -&gt; ... -&gt; ai -&gt; b
name x1 x2 ... xi = y</code></pre>
<p>Here the type of <code>x1</code> is <code>a1</code>, the type of <code>x2</code> is <code>a2</code>, and so on until the type of <code>xi</code> is <code>ai</code>, and finally, the type of <code>y</code> is <code>b</code>.</p>
<p>For example, here is the divides function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; divides ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> divides d n <span class="fu">=</span> rem n d <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>This function takes in two integers, and returns <code>True</code> when <code>n</code> divided by <code>d</code> has a remainder of <code>0</code>. Here the function <code>rem</code> is the remainder function which is equivalent to <code>n % d</code> in C#. For example,</p>
<pre class=".(haskell)"><code>ghci&gt; divides 2 6
True
ghci&gt; divides 3 12
True
ghci&gt; divides 4 9
False</code></pre>
<h2 id="guards">Guards</h2>
<p>The next step of our prime number test is to define a means of computing the least divisor of a number <code>n</code> that is greater than <code>1</code>. The algorithm is a bit eaiser if we define it in terms of one that computes the least divisor of <code>n</code> greater than or equal to a threshold <code>k</code>. The algorithm is as follows:</p>
<ol style="list-style-type: decimal">
<li>If <code>divides k n</code>, then <code>ldf k n = k</code></li>
<li>If <code>k^2 &gt; n</code>, then <code>ldf k n = n</code></li>
<li>Otherwise <code>ldf k n = ldf (k+1) n</code></li>
</ol>
<p>So we need to find a way to write a function which uses a condition, and a means of doing recursion, because the previous description calls <code>ldf</code> again in the result.</p>
<p>There are two ways to define <code>ldf</code>. The first way is as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ldf1 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ldf1 k n <span class="fu">=</span> <span class="kw">if</span> (divides k n)
<span class="ot">&gt;</span>            <span class="kw">then</span> k
<span class="ot">&gt;</span>            <span class="kw">else</span> <span class="kw">if</span> (k<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> n)
<span class="ot">&gt;</span>                 <span class="kw">then</span> n
<span class="ot">&gt;</span>                 <span class="kw">else</span> ldf1 (k<span class="fu">+</span><span class="dv">1</span>) n</code></pre></div>
<p>This function definition uses the if-then-else expression <code>if b then e1 else e2</code> where <code>b</code> is a boolean, <code>e1</code> has some type <code>a</code>, and <code>e2</code> has the same type <code>a</code>.</p>
<p>However, there is a better way using what are called <em>guards</em>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ldf ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> divides k n <span class="fu">=</span> k
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> k<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> n <span class="fu">=</span> n
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> otherwise <span class="fu">=</span> ldf1 (k<span class="fu">+</span><span class="dv">1</span>) n</code></pre></div>
<p>This is called a <em>guarded equation</em> which has the general form:</p>
<pre class=".(haskell)"><code>name x1 x2 ... xi | b1 = y1
name x1 x2 ... xi | b2 = y2
name x1 x2 ... xi | b3 = y3
name x1 x2 ... xi | b4 = y4
...
name x1 x2 ... xi | otherwise = yj</code></pre>
<p>Each of the <code>x1 ... xi</code> are the arguments to the function, and each <code>b1 ... bj</code> are booleans and are called <em>guards</em>. Finally, each of <code>y1 ... yj</code> are the respective bodies of the function. Ghci evaluates this function by starting at the first equation, and determining if <code>b1</code> is true, if it is, then the function returns <code>y1</code>, but if it is false, then Haskell movies on to the second equation and determines if <code>b2</code> is true, and if it is, then returns <code>y2</code>, and so on. Notice that the guard in the last equation is <code>otherwise</code>, this is the “catch all” case. That is, it is exactly like <code>else</code> in an if-then-else expression, and thus, if all the guards on the previous equations are false, then this equation is chosen.</p>
<p>So consider <code>ldf 7 24</code>. First, ghci checks to see if <code>divides 7 24</code> is true, but it is false, and so abandons that equation and moves onto the second one, and asks if <code>k^2 &gt; n</code>, and it is, and so <code>ldf 7 24 = 24</code>.</p>
<p>As a second example, consider <code>ldf 7 2224</code>. Notice that <code>7</code> does not divide <code>2224</code>, nor is <code>7^2 &gt; 2224</code>, and thus, the equation ghci runs is the third equation, because that is the catch all case. Thus, <code>ldf 7 2224 = ldf (7+1) 2224 = ldf 8 2224</code>. In this branch we make a recursive call which increases the first argument by one. Finally, we can see that <code>divides 8 2224</code> is true, and hence, <code>ldf 7 2224 = ldf 8 2224 = 8</code>.</p>
<p>Note that in Haskell doing recursive calls is easy, because we can simply call the function again within the body of the function. This is just like mathematics! In this class all functions we define must be terminating, and thus, one must make sure that when making a recursive call to increase or decrease at least one argument to the function, so that it tends towards the base cases. In <code>ldf</code> we increase by one, because we know from algebra that it is a property of the least divisor function that we will eventually find the least divisor greater than <code>k</code>.</p>
<p>Using <code>ldf</code> we can define the least common divisor function as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ld ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ld n <span class="fu">=</span> ldf <span class="dv">2</span> n</code></pre></div>
<p>Here are a few examples:</p>
<pre class=".(haskell)"><code>ghci&gt; ld 14
2
ghci&gt; ld 15
3
ghci&gt; ld 16
2
ghci&gt; ld 55
5</code></pre>
<p>At this point we have everything we need to define a prime number test.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> isPrime n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">1</span> <span class="fu">=</span> error <span class="st">&quot;not a positive integer&quot;</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">1</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> otherwise <span class="fu">=</span> ld n <span class="fu">==</span> n</code></pre></div>
<p>In the definition of <code>isPrime</code> we used a bit a simplified form of the guards. This definition is equivalent to the following one:</p>
<pre class=".(haskell)"><code>isPrime n | n &lt; 1 = error &quot;not a positive integer&quot;
isPrime n | n == 1 = False
isPrime n | otherwise = ld n == n</code></pre>
<p>The <code>error</code> function tells Haskell to throw an exception and output its argument to STDOUT – the screen – the message. For example,</p>
<p>~<sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><sub><del>.(haskell) ghci&gt; isPrime (-1) Exception: not a positive integer CallStack (from HasCallStack):</del></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></sub></p>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
