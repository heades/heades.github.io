<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - Functions, Pattern Matching, and Polymorphism</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - Functions, Pattern Matching, and Polymorphism </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
	<a href="../lectures.html">Lectures</a>
	<a href="../links.html">Links</a>
        <a href="https://piazza.com/gru/fall2016/csci3300/home">Piazza</a>
        </div>
       
	<br />
	<br />
	<div class="hidden">
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">LectFuns</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (zip,zipWith,curry,uncurry,(.),foldr,foldl,any,all,concatMap,map)</code></pre></div>
</div>
<h2 id="functions">Functions</h2>
<p>In C# the predominant way to structure programs is by using objects and methods. Haskell is a bit different which uses <em>functions</em> to structure programs. Now do not think this means that Haskell lacks in the ability to structure large programs, because as we will see throughout the semester structuring programs using functions is very powerful.</p>
<p>Throughout this section we will design a prime number generator which will require the construction of a number of functions. The general layout of a function in Haskell is as follows:</p>
<pre class=".(haskell)"><code>name :: a1 -&gt; a2 -&gt; ... -&gt; ai -&gt; b
name x1 x2 ... xi = y</code></pre>
<p>Here the type of <code>x1</code> is <code>a1</code>, the type of <code>x2</code> is <code>a2</code>, and so on until the type of <code>xi</code> is <code>ai</code>, and finally, the type of <code>y</code> is <code>b</code>.</p>
<p>For example, here is the divides function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; divides ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> divides d n <span class="fu">=</span> rem n d <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>This function takes in two integers, and returns <code>True</code> when <code>n</code> divided by <code>d</code> has a remainder of <code>0</code>. Here the function <code>rem</code> is the remainder function which is equivalent to <code>n % d</code> in C#. For example,</p>
<pre class=".(haskell)"><code>ghci&gt; divides 2 6
True
ghci&gt; divides 3 12
True
ghci&gt; divides 4 9
False</code></pre>
<h2 id="guards">Guards</h2>
<p>The next step of our prime number test is to define a means of computing the least divisor of a number <code>n</code> that is greater than <code>1</code>. The algorithm is a bit eaiser if we define it in terms of one that computes the least divisor of <code>n</code> greater than or equal to a threshold <code>k</code>. The algorithm is as follows:</p>
<ol style="list-style-type: decimal">
<li>If <code>divides k n</code>, then <code>ldf k n = k</code></li>
<li>If <code>k^2 &gt; n</code>, then <code>ldf k n = n</code></li>
<li>Otherwise <code>ldf k n = ldf (k+1) n</code></li>
</ol>
<p>So we need to find a way to write a function which uses a condition, and a means of doing recursion, because the previous description calls <code>ldf</code> again in the result.</p>
<p>There are two ways to define <code>ldf</code>. The first way is as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ldf1 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ldf1 k n <span class="fu">=</span> <span class="kw">if</span> (divides k n)
<span class="ot">&gt;</span>            <span class="kw">then</span> k
<span class="ot">&gt;</span>            <span class="kw">else</span> <span class="kw">if</span> (k<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> n)
<span class="ot">&gt;</span>                 <span class="kw">then</span> n
<span class="ot">&gt;</span>                 <span class="kw">else</span> ldf1 (k<span class="fu">+</span><span class="dv">1</span>) n</code></pre></div>
<p>This function definition uses the if-then-else expression <code>if b then e1 else e2</code> where <code>b</code> is a boolean, <code>e1</code> has some type <code>a</code>, and <code>e2</code> has the same type <code>a</code>.</p>
<p>However, there is a better way using what are called <em>guards</em>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ldf ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> divides k n <span class="fu">=</span> k
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> k<span class="fu">^</span><span class="dv">2</span> <span class="fu">&gt;</span> n <span class="fu">=</span> n
<span class="ot">&gt;</span> ldf k n <span class="fu">|</span> otherwise <span class="fu">=</span> ldf1 (k<span class="fu">+</span><span class="dv">1</span>) n</code></pre></div>
<p>This is called a <em>guarded equation</em> which has the general form:</p>
<pre class=".(haskell)"><code>name x1 x2 ... xi | b1 = y1
name x1 x2 ... xi | b2 = y2
name x1 x2 ... xi | b3 = y3
name x1 x2 ... xi | b4 = y4
...
name x1 x2 ... xi | otherwise = yj</code></pre>
<p>Each of the <code>x1 ... xi</code> are the arguments to the function, and each <code>b1 ... bj</code> are booleans and are called <em>guards</em>. Finally, each of <code>y1 ... yj</code> are the respective bodies of the function. Ghci evaluates this function by starting at the first equation, and determining if <code>b1</code> is true, if it is, then the function returns <code>y1</code>, but if it is false, then Haskell movies on to the second equation and determines if <code>b2</code> is true, and if it is, then returns <code>y2</code>, and so on. Notice that the guard in the last equation is <code>otherwise</code>, this is the “catch-all” case. That is, it is exactly like <code>else</code> in an if-then-else expression, and thus, if all the guards on the previous equations are false, then this equation is chosen.</p>
<p>So consider <code>ldf 7 24</code>. First, ghci checks to see if <code>divides 7 24</code> is true, but it is false, and so abandons that equation and moves onto the second one, and asks if <code>k^2 &gt; n</code>, and it is, and so <code>ldf 7 24 = 24</code>.</p>
<p>As a second example, consider <code>ldf 7 2224</code>. Notice that <code>7</code> does not divide <code>2224</code>, nor is <code>7^2 &gt; 2224</code>, and thus, the equation ghci runs is the third equation, because that is the catch-all case. Thus, <code>ldf 7 2224 = ldf (7+1) 2224 = ldf 8 2224</code>. In this branch we make a recursive call which increases the first argument by one. Finally, we can see that <code>divides 8 2224</code> is true, and hence, <code>ldf 7 2224 = ldf 8 2224 = 8</code>.</p>
<p>Note that in Haskell doing recursive calls is easy, because we can simply call the function again within the body of the function. This is just like mathematics! In this class all functions we define must be terminating, and thus, one must make sure that when making a recursive call to increase or decrease at least one argument to the function, so that it tends towards the base cases. In <code>ldf</code> we increase by one, because we know from algebra that it is a property of the least divisor function that we will eventually find the least divisor greater than <code>k</code>.</p>
<p>Using <code>ldf</code> we can define the least common divisor function as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ld ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> ld n <span class="fu">=</span> ldf <span class="dv">2</span> n</code></pre></div>
<p>Here are a few examples:</p>
<pre class=".(haskell)"><code>ghci&gt; ld 14
2
ghci&gt; ld 15
3
ghci&gt; ld 16
2
ghci&gt; ld 55
5</code></pre>
<p>At this point we have everything we need to define a prime number test.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> isPrime n <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">1</span> <span class="fu">=</span> error <span class="st">&quot;not a positive integer&quot;</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">1</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> otherwise <span class="fu">=</span> ld n <span class="fu">==</span> n</code></pre></div>
<p>In the definition of <code>isPrime</code> we used a bit a simplified form of the guards. This definition is equivalent to the following one:</p>
<pre class=".(haskell)"><code>isPrime n | n &lt; 1 = error &quot;not a positive integer&quot;
isPrime n | n == 1 = False
isPrime n | otherwise = ld n == n</code></pre>
<p>The <code>error</code> function tells Haskell to throw an exception and output its argument to STDOUT – the screen – the message. For example,</p>
<pre class=".(haskell)"><code>ghci&gt; isPrime (-1)
** Exception: not a positive integer
CallStack (from HasCallStack):
  error, called at lectures/lec-functions-patternmatching-polymorphism.lhs:164:21 in main:LectFuns
ghci&gt; </code></pre>
<p>Keep in mind that this exception cannot be caught, and it causes the current execution to be terminated.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>There is one extremely powerful tool Haskell – as well as many other functional programming languages – provides called <em>pattern matching</em>. This allows one to case split on the shape of a data type. First, we will concentrate on pattern matching on input arguments, and then discuss a more general form which allows for one to case split on the outputs of function calls.</p>
<p>We begin with an example. Suppose we wished to define disjunction over the booleans. One way would be to use guards:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or1 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or1 b1 b2 <span class="fu">|</span> b1 <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> b2 <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>This works, but consider a second way:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or2 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or2 <span class="dt">True</span> b2 <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> or2 b1 <span class="dt">True</span> <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> or2 b1 b2 <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>The function <code>or2</code> uses pattern matching on the input arguments by enforcing when either <code>b1</code> or <code>b2</code> are <code>True</code>. Consider the first equation of <code>or2</code>, this equation states that <code>b1</code> must be <code>True</code>, and if during evaluation it is not, then Haskell will move on to the next equation where it will check to see if <code>b2</code> is <code>True</code>. In the second equation, <code>b1</code> means that the first argument can be either <code>True</code> or <code>False</code>, but if during evaluation this argument is chosen, then it is necessarily the case that <code>b1</code> is <code>False</code>, or the first equation would have triggered. Finally, if during evaluation the third equation is chosen, then both inputs must be <code>False</code>.</p>
<p>Haskell’s evaluation strategy is called “call-by-need evaluation.” This means that Haskell will only evaluate a program when it needs its value and in all other cases it will leave the program completely unevaluated. Consider as an example the following two functions:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; foo ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> foo <span class="dv">0</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> foo n <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; bar ::</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> bar <span class="fu">=</span> or2 <span class="dt">True</span> (foo <span class="dv">5</span>)</code></pre></div>
<p>When evaluating <code>bar</code> Haskell will evaluate as little as possible to determine the output of <code>or2</code>, and hence, since the first argument is <code>True</code> Haskell does not have to evaluate <code>foo 5</code> at all, and in fact, it does not evaluate it, and simply returns <code>True</code>, because that is all it needs to determine the correct output. This style of evaluation is often called <em>lazy evaluation</em> for obvious reasons.</p>
<p>Here is a third way to define this function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or3 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or3 <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> or3 b1 b2 <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>In this version we use pattern matching to determine when the function should be <code>False</code>, and then leave the catch-all case to handle when it should return <code>True</code>.</p>
<p>We can simplfy this function one last time:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or4 ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> or4 <span class="dt">False</span> <span class="dt">False</span> <span class="fu">=</span> <span class="dt">False</span>
<span class="ot">&gt;</span> or4 _ _ <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>Notice that in the definition of <code>or3</code> the second equation does not use the variables <code>b1</code> and <code>b2</code> in the body of the function. This new definition tells Haskell to ignore those inputs completely, because we are not going to use them. The <code>_</code> is called the “joker”. It can be read as “I don’t care what this argument is, in fact, I am not even going to use it.”</p>
<p>Booleans are fun, but they do not have a lot of structure, and so it is hard to see just how powerful pattern matching is. Recall that every list <code>[x1,x2,x3,...,xi]</code> is just syntactic sugar for the list <code>x1 : x2 : x3 : ... : xi : []</code>. In addition, both of the previous lists are equivalent to <code>x1:[x2,x3,...,xi]</code>. It turns out that the latter form can be used to pattern match on lists.</p>
<p>Consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; firstInt ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> firstInt [] <span class="fu">=</span> error <span class="st">&quot;empty list has no first integer&quot;</span>
<span class="ot">&gt;</span> firstInt (i<span class="fu">:</span>rest) <span class="fu">=</span> i</code></pre></div>
<p>We know that either a list is empty or it has at least one element inside of it. The first equation in <code>firstInt</code> checks to see if the input list is empty, and if so outputs an error. If during evaluation the second equation is hit, then we know that the list cannot be empty, because Haskell starts with the first equation and moves downward until it matches the pattern. The pattern <code>i:rest</code> tells Haskell to name the first element of the input list <code>i</code>, and to name the remainder of the list <code>rest</code>. For example, suppose we applied <code>firstInt</code> to the list <code>[1,2,3]</code>, then we know that this list is equivalent to the list <code>1:[2,3]</code>. Haskell will then set <code>i = 1</code>, and <code>rest = [2,3]</code>.</p>
<p>Let us check to see if this is the case by writing a program to show us the values of <code>i</code> and <code>rest</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ext ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">Int</span>, [<span class="dt">Int</span>])
<span class="ot">&gt;</span> ext [] <span class="fu">=</span> error <span class="st">&quot;ext doesn't like the empty list&quot;</span>
<span class="ot">&gt;</span> ext (i<span class="fu">:</span>rest) <span class="fu">=</span> (i,rest)</code></pre></div>
<p>The return type of the previous function is a pair type, and has the form <code>(a,b)</code> where <code>a</code> and <code>b</code> are some other types. It is simply the type of all pairs where the first projection is of type <code>a</code> and the second projection is of type <code>b</code>. Thus, <code>(1,2)</code> has type <code>(Int,Int)</code>, and the pair <code>(1,[2,3])</code> has type <code>(Int,[Int])</code>. The pair <code>(42,True)</code> has type <code>(Int, Bool)</code>.</p>
<p>Now we can run our test using <code>ext</code>:</p>
<pre class=".(haskell)"><code>ghci&gt; ext [1,2,3]
(1,[2,3])</code></pre>
<p>The real power of pattern matching comes in when it is mixed with recursion. First, notice that we can place an ordering on lists. The empty list is the smallest list, and we have the following:</p>
<pre class=".(haskell)"><code>x:xs &gt; xs</code></pre>
<p>We call an ordering like this a <em>structural ordering</em>, because it decreases with the structure of the data type. Using this structural ordering we can write terminating structurally recursive functions.</p>
<p>Consider the following example:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; double ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
<span class="ot">&gt;</span> double [] <span class="fu">=</span> []
<span class="ot">&gt;</span> double (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>x <span class="fu">:</span> double xs</code></pre></div>
<p>First, <code>double</code> pattern matches on the input list, and if it is empty, then it simply returns the empty list, but if the input is not empty then <code>double</code> returns a new list with the head set to <code>2*x</code>, but we compute the tail of the list by recursion effectively doubling the rest of the list. Notice that the recursive call is applied to <code>xs</code> which is a structurally smaller list than the input. This tells us that we know <code>double</code> will eventually terminate.</p>
<p>Pattern matching can work with other data types as well. For example, if we need to get access to the projections of a pair we can use pattern matching.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; proj1 ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> proj1 (x,y) <span class="fu">=</span> x
<span class="ot">&gt;</span> 
<span class="ot">&gt; proj2 ::</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> proj2 (x,y) <span class="fu">=</span> y</code></pre></div>
<p>Every data type supports pattern matching.</p>
<h2 id="higher-order-functions">Higher-Order functions</h2>
<p>Recall that every a function type</p>
<pre class=".(haskell)"><code>a1 -&gt; a2 -&gt; ... -&gt; a(i-1) -&gt; ai</code></pre>
<p>is full parenthesized as</p>
<pre class=".(haskell)"><code>a1 -&gt; (a2 -&gt; ... -&gt; (a(i-1) -&gt; ai))</code></pre>
<p>Hence, a type <code>a1 -&gt; a2 -&gt; a3 -&gt; a4</code> is fully parenthesized as <code>a1 -&gt; (a2 -&gt; (a3 -&gt; a4))</code>. This implies that every function in Haskell, and indeed in any functional programming language, is an unary function that takes in one input, and returns a function that may be waiting for another input.</p>
<p>Consider the following function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zip ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]
<span class="ot">&gt;</span> zip (a<span class="fu">:</span>as) (b<span class="fu">:</span>bs) <span class="fu">=</span> (a,b) <span class="fu">:</span> zip as bs
<span class="ot">&gt;</span> zip _ _ <span class="fu">=</span> []</code></pre></div>
<p>The previous function is equivalent to the following one:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zip' ::</span> [a] <span class="ot">-&gt;</span> ([b] <span class="ot">-&gt;</span> [(a,b)])
<span class="ot">&gt;</span> zip' (a<span class="fu">:</span>as) <span class="fu">=</span>
<span class="ot">&gt;</span>        \l <span class="ot">-&gt;</span> <span class="kw">case</span> l <span class="kw">of</span>
<span class="ot">&gt;</span>                (b<span class="fu">:</span>bs) <span class="ot">-&gt;</span> (a,b) <span class="fu">:</span> zip' as bs
<span class="ot">&gt;</span>                _ <span class="ot">-&gt;</span> []
<span class="ot">&gt;</span> zip' _ <span class="fu">=</span> \l <span class="ot">-&gt;</span> []    </code></pre></div>
<p>The expression <code>\x -&gt; e</code> is called a <span class="math inline"><em>λ</em></span>-expression, which are the anonymous functions of Haskell; they are equivalent to <span class="math inline">fun  ⇒ <em>e</em></span> in Functional Iffy. The function <code>zip'</code> takes a single input, and then outputs another function that is waiting for the second input. In fact, <code>zip</code> is syntactic sugar for <code>zip'</code>.</p>
<p>Every function being unary comes with a very nice property called <em>partial application</em>. This is where a function is applied to only a few inputs, and not all of them. For example,</p>
<pre class=".(haskell)"><code>ghci&gt; :t zip [1]
zip [1] :: [Integer] -&gt; [(Integer, Integer)]</code></pre>
<p>Here we asked for the type of <code>zip [1]</code>, and we can see that it is indeed a function waiting for an integer-list input. Now checkout:</p>
<pre class=".(haskell)"><code>ghci&gt; let z = zip [1] in z [2]
[(1,2)]</code></pre>
<p>So we can see that <code>zip [1]</code> is indeed a function, that can be applied to a second list.</p>
<p>We have only considered functions that return functions as output, but what about functions that take functions as input? This is also supported in Haskell, and any other functional programming language.</p>
<p>Consider the <code>zipWith</code> function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zipWith ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]
<span class="ot">&gt;</span> zipWith f (a<span class="fu">:</span>as) (b<span class="fu">:</span>bs) <span class="fu">=</span> (f a b) <span class="fu">:</span> zipWith f as bs
<span class="ot">&gt;</span> zipWith _ _ _ <span class="fu">=</span> []</code></pre></div>
<p>This function takes as input a binary function <code>f : a -&gt; b -&gt; c</code>, a list of first arguments, and a list of second arguments, but then collects all of the outputs into a list.</p>
<p>Functions that take in functions as arguments or returns arguments as output are called <em>higher-order functions</em> and they are the driving force of functional programming. The real power of functional programming comes from higher-order functions.</p>
<p>We consider some further examples. The three most used functions in all of functional programming has to be <code>map</code>, <code>foldl</code>, and <code>foldr</code>. A map takes a function, and applied it accross a list:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; map ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
<span class="ot">&gt;</span> map f [] <span class="fu">=</span> []
<span class="ot">&gt;</span> map f (x<span class="fu">:</span>xs) <span class="fu">=</span> (f x) <span class="fu">:</span> map f xs</code></pre></div>
<p>The recursive pattern of the definition of map pops up all the time in functional programming. Here is an example evaluation of <code>map</code>. Suppose we have the following function on characters:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mangle ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
<span class="ot">&gt;</span> mangle x <span class="fu">|</span> x <span class="fu">==</span> <span class="ch">'a'</span> <span class="fu">||</span> x <span class="fu">==</span> <span class="ch">'A'</span> <span class="fu">=</span> <span class="ch">'Z'</span>
<span class="ot">&gt;</span> mangle x <span class="fu">|</span> x <span class="fu">==</span> <span class="ch">'h'</span> <span class="fu">||</span> x <span class="fu">==</span> <span class="ch">'H'</span> <span class="fu">=</span> <span class="ch">'*'</span>
<span class="ot">&gt;</span> mangle x <span class="fu">|</span> x <span class="fu">==</span> <span class="ch">'l'</span> <span class="fu">||</span> x <span class="fu">==</span> <span class="ch">'L'</span> <span class="fu">=</span> <span class="ch">'$'</span>
<span class="ot">&gt;</span> mangle x <span class="fu">=</span> x</code></pre></div>
<p>Then <code>map</code> evaluates like so:</p>
<pre class=".(haskell)"><code>map mangle &quot;Haskell&quot; 
~&gt; (mangle 'H') : map mangle &quot;askell&quot;
~&gt; (mangle 'H') : (mangle 'a') : map mangle &quot;skell&quot;
~&gt; (mangle 'H') : (mangle 'a') : (mangle 's') : map mangle &quot;kell&quot;
~&gt; (mangle 'H') : (mangle 'a') : (mangle 's') : (mangle 'k') : map mangle &quot;ell&quot;
~&gt; (mangle 'H') : (mangle 'a') : (mangle 's') : (mangle 'k') : (mangle 'e') : map mangle &quot;ll&quot;
~&gt; (mangle 'H') : (mangle 'a') : (mangle 's') : (mangle 'k') : (mangle 'e') : (mangle 'l') : map mangle &quot;l&quot;
~&gt; (mangle 'H') : (mangle 'a') : (mangle 's') : (mangle 'k') : (mangle 'e') : (mangle 'l') : (mangle 'l') : map mangle &quot;&quot;
~&gt; (mangle 'H') : (mangle 'a') : (mangle 's') : (mangle 'k') : (mangle 'e') : (mangle 'l') : (mangle 'l') : []
~&gt; '*' : (mangle 'a') : (mangle 's') : (mangle 'k') : (mangle 'e') : (mangle 'l') : (mangle 'l') : []
~&gt; '*' : 'Z' : (mangle 's') : (mangle 'k') : (mangle 'e') : (mangle 'l') : (mangle 'l') : []
~&gt; '*' : 'Z' : 's' : (mangle 'k') : (mangle 'e') : (mangle 'l') : (mangle 'l') : []
~&gt; '*' : 'Z' : 's' : 'k' : (mangle 'e') : (mangle 'l') : (mangle 'l') : []
~&gt; '*' : 'Z' : 's' : 'k' : 'e' : (mangle 'l') : (mangle 'l') : []
~&gt; '*' : 'Z' : 's' : 'k' : 'e' : 'l' : (mangle 'l') : []
~&gt; '*' : 'Z' : 's' : 'k' : 'e' : '$' : '$' : []
= &quot;*Zske$$&quot;</code></pre>
<p>So map allows one to apply an operation accross a collection of data, but folds allow one to reduce a collection to some other value. There are two types of folds: left folds and right folds.</p>
<p>First, we consider the left fold:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; foldl ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> foldl f x [] <span class="fu">=</span> x
<span class="ot">&gt;</span> foldl f x (a<span class="fu">:</span>as) <span class="fu">=</span> foldl f (f x a) as</code></pre></div>
<p>Think of <code>x</code> in the definition of <code>foldl</code> as an accumilator which accumilates repeatedly applying <code>f</code> starting with <code>x</code>. Suppose we wanted to reverse a list. One way we saw to do it earlier in this course is to do the following:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; reverseBad ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> reverseBad [] <span class="fu">=</span> []
<span class="ot">&gt;</span> reverseBad (x<span class="fu">:</span>xs) <span class="fu">=</span> reverseBad xs <span class="fu">++</span> [x]</code></pre></div>
<p>This version of <code>reverse</code> is bad, because it is not tail recrusive, and it has an expoential runtime, because the use of append requires us to go through the input list multiple times.</p>
<p>If we use a well-known pattern called the <em>accumilator pattern</em> we can rewrite <code>reverse</code> so that it is tail recursive, and has a linear runtime cost. This pattern says to add an additional argument to the program we are interested in, and use it to <em>accumilate</em> the return value. First, we define an auxiliary function that computes the reverse of a list, but uses an accumilator:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; reverseAux ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> reverseAux acc [] <span class="fu">=</span> acc
<span class="ot">&gt;</span> reverseAux acc (a<span class="fu">:</span>as) <span class="fu">=</span> reverseAux (a<span class="fu">:</span>acc) as</code></pre></div>
<p>The second argument to <code>reverseAux</code> is the list we want to reverse, but the first argument is the accumilator. Its job is to accumilate the ultimate return value, which in this example happens to be the reversed list. This will force the step case to be tail recursive.</p>
<p>Now we can define the reverse function interms of <code>reverseAux</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; reverse' ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> reverse' l <span class="fu">=</span> reverseAux [] l</code></pre></div>
<p>We can think of the accumilator in <code>reverseAux</code> as a global variable. Then in <code>reverse'</code> we initialize this variable to the empty list. The runtime of <code>reverse</code> is indeed linear.</p>
<p>The first argument to the function <code>revAux</code> is the accumilator. Now compare the structure of <code>foldl</code> and the structure of <code>reverseAux</code>. We can see a pattern. The left fold <code>foldl</code> embodies the accumilator pattern. Thus, we can use <code>foldl</code> whenever we want to accumilate, so for example, we can define <code>reverse</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; reverse ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> reverse l <span class="fu">=</span> foldl revAux [] l
<span class="ot">&gt;</span>  <span class="kw">where</span>
<span class="ot">&gt;   revAux ::</span> [a] <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span>   revAux acc x <span class="fu">=</span> x<span class="fu">:</span>acc</code></pre></div>
<p>When you think accumilator, think <code>foldl</code>. Now we can do an evaluation of <code>reverse</code> to see how <code>foldl</code> works:</p>
<pre class=".(haskell)"><code>reverse [1,2,3]
~&gt; foldl revAux [] [1,2,3]
~&gt; foldl revAux (revAux [] 1) [2,3]
~&gt; foldl revAux (revAux (revAux [] 1) 2) [3]
~&gt; foldl revAux (revAux (revAux (revAux [] 1) 2) 3) []
~&gt; revAux (revAux (revAux [] 1) 2) 3
~&gt; revAux (revAux (1:[]) 2) 3
~&gt; revAux (2:1:[]) 3
~&gt; 3:2:1:[]</code></pre>
<p>Another common fold is the <em>right fold</em> called <code>foldr</code>, and it is defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> foldr f x [] <span class="fu">=</span> x
<span class="ot">&gt;</span> foldr f x (y<span class="fu">:</span>ys) <span class="fu">=</span> f y (foldr f x ys)</code></pre></div>
<p>Suppose we have a list <code>[x1,x2,x3,x4,x5,x6]</code>, a <code>x : b</code>, and a function <code>f : a -&gt; b -&gt; b</code>, then the <code>foldr</code> function computes the following:</p>
<pre class=".(haskell)"><code>foldr f x [x1,x2,x3,x4,x5,x6]
~&gt; f x1 (foldr f x [x2,x3,x4,x5,x6])
~&gt; f x1 (f x2 (foldr f x [x3,x4,x5,x6]))
~&gt; f x1 (f x2 (f x3 (foldr f x [x4,x5,x6])))
~&gt; f x1 (f x2 (f x3 (f x4 (foldr f x [x5,x6]))))
~&gt; f x1 (f x2 (f x3 (f x4 (f x5 (foldr f x [x6])))))
~&gt; f x1 (f x2 (f x3 (f x4 (f x5 (f x6 (foldr f x []))))))
~&gt; f x1 (f x2 (f x3 (f x4 (f x5 (f x6 x)))))</code></pre>
<p>As an example, suppose we have a list of lists, and we want to flatten that list into a list of all the elements that occur in the inner lists. We can do this using <code>foldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; flatten ::</span> [[a]] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> flatten l <span class="fu">=</span> foldr (<span class="fu">++</span>) [] l</code></pre></div>
<p>Here is an example evaluation:</p>
<pre class=".(haskell)"><code>flatten [[1,2],[3,4],[42,24]]
~&gt; foldr (++) [] [[1,2],[3,4],[42,24]]
~&gt; [1,2] ++ (foldr (++) [] [[3,4],[42,24]])
~&gt; [1,2] ++ ([3,4] ++ (foldr (++) [] [[42,24]]))
~&gt; [1,2] ++ ([3,4] ++ ([42,24] ++ (foldr (++) [] [])))
~&gt; [1,2] ++ ([3,4] ++ ([42,24] ++ []))
~&gt; [1,2] ++ ([3,4] ++ [42,24])
~&gt; [1,2] ++ [3,4,42,24]
~&gt; [1,2,3,4,42,24]</code></pre>
<p>Higher-order functions give rise to what is called <em>pointfree programming</em> where we try to use actual inputs as little as possible. Recall the following example from above:</p>
<pre class=".(haskell)"><code>flatten :: [[a]] -&gt; [a]
flatten l = foldr (++) [] l</code></pre>
<p>Input variables like <code>l</code> are called points. We can turn the definition of <code>flatten</code> into point-free style by not naming any of the inputs, and simply construct a function as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; flattenPF ::</span> [[a]] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> flattenPF <span class="fu">=</span> foldr (<span class="fu">++</span>) []</code></pre></div>
<p>Notice that we do not name the input list, that is, we do not require a point. Let’s think about this from a type perspective. The type of <code>flattenPF</code> is <code>[[a]] -&gt; [a]</code>, but the type of <code>flattenPF l</code> – we are naming the input <code>l</code> – is <code>[a]</code>. Furthermore, the type of <code>foldr (++) []</code> is <code>[[a]] -&gt; [a]</code>, and thus, we really do not need to name the input, because we have a function with the same type as <code>flattenPF</code>.</p>
<p>Constructing complex point-free programs requires the use of function composition, which is another example of a higher-order function. We need the following higher-order function:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; (.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)
<span class="ot">&gt;</span> (g <span class="fu">.</span> f) a <span class="fu">=</span> g (f a)</code></pre></div>
<p>Function composition allows us to chain several functions together like a pipe. For example, if I have four functions <code>f :: a -&gt; b</code>, <code>g :: b -&gt; c</code>, <code>h :: c -&gt; d</code>, and <code>i :: d -&gt; e</code>, then suppose I want to first run <code>f</code>, and then run <code>g</code> on the output of <code>f</code>, but then run <code>h</code> on the output of that, and so on, but this is equivalent to defining a function from <code>a -&gt; e</code> by chaining each of the functions together. So we can do this using function composition as follows:</p>
<pre class=".(haskell)"><code>i.h.g.f :: a -&gt; e</code></pre>
<p>Suppose we want to take a list of lists of integers, and first flatten it, but then double each element. Then we can do this in point-free style as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; collapseDouble ::</span> [[<span class="dt">Integer</span>]] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]
<span class="ot">&gt;</span> collapseDouble <span class="fu">=</span> (map (<span class="dv">2</span><span class="fu">*</span>))<span class="fu">.</span>flatten</code></pre></div>
<p>It turns out that any higher-order function that returns a function as output, can be turned into an <span class="math inline"><em>n</em></span>-ary function using pairs as inputs:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; curry ::</span> ((a,b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)
<span class="ot">&gt;</span> curry f a b <span class="fu">=</span> f (a , b)</code></pre></div>
<p>This operation is called <em>currying</em> after the mathematician and logician <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>. This operation also has an inverse called <code>uncurrying</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; uncurry ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> ((a,b) <span class="ot">-&gt;</span> c)
<span class="ot">&gt;</span> uncurry f (a,b) <span class="fu">=</span> f a b</code></pre></div>
<p>We can proof that these are bijections. Suppose <code>f :: (a,b) -&gt; c</code>, <code>x :: a</code>, and <code>y :: b</code>, then we can see show that <code>uncurry</code> is the inverse of <code>curry</code> as follows:</p>
<pre class=".(haskell)"><code>uncurry (curry f) a b
= (curry f) a b
= curry f a b
= f (a, b)</code></pre>
<p>Thus, <code>uncurry (curry f) = f</code>. We can show the opposite. Suppose <code>f :: a -&gt; b -&gt; c</code>.</p>
<pre class=".(haskell)"><code>curry (uncurry f) a b
= (uncurry f) a b
= uncurry f a b
= f a b</code></pre>
<p>Therefore, <code>curry (uncurry f) = f</code>. These two proofs show that functions of type <code>a -&gt; (b -&gt; c)</code> are isomorphic – essentially equivalent to functions of type <code>(a,b) -&gt; c</code>.</p>
<p>We can phrase these mutual inverse properties as test cases as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; curryUncurry1 ::</span> <span class="dt">Eq</span> c <span class="ot">=&gt;</span> ((a,b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> curryUncurry1 f a b <span class="fu">=</span> (uncurry (curry f)) (a,b) <span class="fu">==</span> f (a,b)
<span class="ot">&gt;</span> 
<span class="ot">&gt; curryUncurry2 ::</span> <span class="dt">Eq</span> c <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> curryUncurry2 f a b <span class="fu">=</span> (curry (uncurry f)) a b <span class="fu">==</span> f a b</code></pre></div>
<p>One important thing about currying is that we can view it as a test for whether or not a programming language supports general higher-order functions, and hence, functional programming. Any programming language that doesn’t cannot be called functional.</p>
<p>Currying and uncurrying also allow us to choose a representation to fit the problem we might be modeling. For example, if I am programming with a coordinate system, then I would use functions of type <code>(a,b) -&gt; c</code>, but then this doesn’t fit the type of functions for some of the higher-order operations we have been studying, but I know that I can always curry my function to put its type in the right form.</p>
<h2 id="polymorphism">Polymorphism</h2>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
