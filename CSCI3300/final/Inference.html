<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - Inference</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - Inference </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
	<a href="../lectures.html">Lectures</a>
	<a href="../links.html">Links</a>
        <a href="https://piazza.com/gru/fall2017/csci3300/home">Piazza</a>
        </div>
       
	<br />
	<br />
	<h1 id="type-inference">Type Inference</h1>
<div class="hidden">
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeSynonymInstances, FlexibleContexts, OverlappingInstances, FlexibleInstances #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Error</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Writer</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span> (forM, forM_)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span> (transpose, intercalate)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Applicative</span> ((&lt;$&gt;))
<span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Text.PrettyPrint</span> <span class="kw">as</span> <span class="dt">PP</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Concurrent.STM</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Exit</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.IO.Unsafe</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.IORef</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> quickCheckN n <span class="fu">=</span> quickCheckWith <span class="fu">$</span> stdArgs { maxSuccess <span class="fu">=</span> n}</code></pre></div>
</div>
<p>In this problem, we will take the bare-bones language for which we studied <a href="../lectures/inference.html">type inference</a>, add features to it, and update the inference to work with those features.</p>
<h2 id="a-pairs">(a) Pairs</h2>
<p>The first feature we will add is pairs, ie tuples of size 2. Specifically, we have extended the language of expressions <code>Expr</code> to include</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">...</span>
         <span class="fu">|</span> <span class="dt">Exp</span> <span class="ot">`ECom`</span> <span class="dt">Exp</span>  <span class="co">-- Construct a pair of two expressions</span>
         <span class="fu">|</span> <span class="dt">EFst</span>  <span class="dt">Exp</span>         <span class="co">-- Extract the first  element of a pair</span>
	     <span class="fu">|</span> <span class="dt">ESnd</span>  <span class="dt">Exp</span>         <span class="co">-- Extract the second element of a pair</span></code></pre></div>
<p>Correspondingly, we have extended the language of types to include</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Type</span> <span class="fu">=</span> <span class="fu">...</span> 
          <span class="fu">|</span>  <span class="dt">Type</span> <span class="ot">`TCom`</span> <span class="dt">Type</span> <span class="co">-- Pair of two types</span></code></pre></div>
<p>Extend the definition of the <code>mgu</code> and <code>ti</code> functions to correctly infer types for the extended language.</p>
<p>When you are done, you should be able to infer that the expression</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> eSwap <span class="fu">=</span> <span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>) <span class="fu">$</span> (<span class="dt">ELet</span> (<span class="dt">EV</span> <span class="st">&quot;a&quot;</span>) (<span class="dt">EFst</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>)))
<span class="ot">&gt;</span>                         (<span class="dt">ELet</span> (<span class="dt">EV</span> <span class="st">&quot;b&quot;</span>) (<span class="dt">ESnd</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>)))
<span class="ot">&gt;</span>                         (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;b&quot;</span>) <span class="ot">`ECom`</span> <span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;a&quot;</span>))))</code></pre></div>
<p>has the type (equivalent to)</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> tSwap <span class="fu">=</span> <span class="dt">Forall</span> [<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TV</span> <span class="st">&quot;b&quot;</span>] <span class="fu">$</span>
<span class="ot">&gt;</span>           (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>) <span class="ot">`TCom`</span> <span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;b&quot;</span>)) <span class="ot">`TArr`</span> ((<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;b&quot;</span>) <span class="ot">`TCom`</span> <span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>)))</code></pre></div>
<h2 id="b-lists">(b) Lists</h2>
<p>Next, let us add lists, to the language. Specifically, we extend the language of expressions <code>Expr</code> to include</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">...</span>
         <span class="fu">|</span> <span class="dt">ENil</span>            <span class="co">-- empty list</span>
         <span class="fu">|</span> <span class="dt">Exp</span> <span class="ot">`ECons`</span> <span class="dt">Exp</span> <span class="co">-- head &quot;cons-ed&quot; to a tail</span>
	     <span class="fu">|</span> <span class="dt">EIsNil</span> <span class="dt">Exp</span>      <span class="co">-- test if a list is empty</span>
	     <span class="fu">|</span> <span class="dt">EDcons</span> <span class="dt">Exp</span>      <span class="co">-- return a pair of (head, tail) of (non-empty) list</span></code></pre></div>
<p>Correspondingly, we have extended the language of types to include</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Type</span> <span class="fu">=</span> <span class="fu">...</span> 
          <span class="fu">|</span> <span class="dt">TList</span> <span class="dt">Type</span>     <span class="co">-- TList t is a list of t values </span></code></pre></div>
<p>Extend the definition of the <code>mgu</code> and <code>ti</code> functions to correctly infer types for the extended language.</p>
<p>When you are done, you should be able to infer that in the environment</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> env   <span class="fu">=</span> Map.fromList 
<span class="ot">&gt;</span>   [ (<span class="dt">EV</span> <span class="st">&quot;plus&quot;</span>, <span class="dt">Forall</span> [] <span class="fu">$</span> tArrs [<span class="dt">TInt</span>, <span class="dt">TInt</span>, <span class="dt">TInt</span>])
<span class="ot">&gt;</span>   , (<span class="dt">EV</span> <span class="st">&quot;ite&quot;</span> , <span class="dt">Forall</span> [<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>] <span class="fu">$</span> tArrs [<span class="dt">TBool</span>, <span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>), <span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>), <span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>)])]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> tenv  <span class="fu">=</span> <span class="dt">TypeEnv</span> env</code></pre></div>
<p>the expressions <code>eHd</code> and <code>eList</code></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> eZero <span class="fu">=</span> <span class="dt">ELit</span> (<span class="dt">LInt</span> <span class="dv">0</span>)
<span class="ot">&gt;</span> eOne  <span class="fu">=</span> <span class="dt">ELit</span> (<span class="dt">LInt</span> <span class="dv">1</span>)
<span class="ot">&gt;</span> ePlus <span class="fu">=</span> <span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;plus&quot;</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> eInc  <span class="fu">=</span> <span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>) <span class="fu">$</span> eApps [ePlus, eOne, <span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>)]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> eHd   <span class="fu">=</span> <span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>) <span class="fu">$</span> <span class="dt">EFst</span> (<span class="dt">EDcons</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>)))
<span class="ot">&gt;</span> eTl   <span class="fu">=</span> <span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>) <span class="fu">$</span> <span class="dt">ESnd</span> (<span class="dt">EDcons</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>)))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> eList <span class="fu">=</span> <span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>) 
<span class="ot">&gt;</span>           (eIf (<span class="dt">EIsNil</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>))) 
<span class="ot">&gt;</span>                eZero
<span class="ot">&gt;</span>                (eInc <span class="ot">`EApp`</span> ((eHd <span class="ot">`EApp`</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;x&quot;</span>))) <span class="ot">`EApp`</span> eZero)))</code></pre></div>
<p>have the respective types</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> tHd   <span class="fu">=</span> <span class="dt">Forall</span> [<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>] <span class="fu">$</span> (<span class="dt">TList</span> (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>))) <span class="ot">`TArr`</span> (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>))
<span class="ot">&gt;</span> tTl   <span class="fu">=</span> <span class="dt">Forall</span> [<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>] <span class="fu">$</span> (<span class="dt">TList</span> (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>))) <span class="ot">`TArr`</span> (<span class="dt">TList</span> (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>)))
<span class="ot">&gt;</span> tList <span class="fu">=</span> <span class="dt">Forall</span> [] ((<span class="dt">TList</span> (<span class="dt">TInt</span> <span class="ot">`TArr`</span> <span class="dt">TInt</span>)) <span class="ot">`TArr`</span> <span class="dt">TInt</span>)</code></pre></div>
<p>where the helper functions are defined</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> tArrs <span class="fu">=</span> foldr1 <span class="dt">TArr</span> 
<span class="ot">&gt;</span> eApps <span class="fu">=</span> foldl1 <span class="dt">EApp</span>
<span class="ot">&gt;</span> eIf   <span class="fu">=</span> \b e1 e2 <span class="ot">-&gt;</span> eApps [<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;ite&quot;</span>), b, e1, e2] </code></pre></div>
<h2 id="c-recursion">(c) Recursion</h2>
<p>Finally, we will add recursive functions to the language, via the following construct.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="fu">...</span>
         <span class="fu">|</span> <span class="dt">ELetrec</span> <span class="dt">EVbl</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="co">-- &quot;ELetrec x e1 e2&quot; allows x to appear in e1</span></code></pre></div>
<p>We need not extend the language of types at all, and hence the <code>mgu</code> function remains the same. However, the tricky bit is to figure out how to break the following cycle: we need to use the type of x to determine the type of e1, but we need to type e1 to determine the type of x!</p>
<p>When you are done, you should be able to infer that the expressions <code>eTl</code> and <code>eLen</code></p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> eLen <span class="fu">=</span> <span class="dt">ERec</span> (<span class="dt">EV</span> <span class="st">&quot;len&quot;</span>) 
<span class="ot">&gt;</span>           (<span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;xs&quot;</span>) <span class="fu">$</span> 
<span class="ot">&gt;</span>              eIf (<span class="dt">EIsNil</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;xs&quot;</span>))) 
<span class="ot">&gt;</span>                  eZero 
<span class="ot">&gt;</span>                  (eInc <span class="ot">`EApp`</span>(((<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;len&quot;</span>)) <span class="ot">`EApp`</span> (eTl <span class="ot">`EApp`</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;xs&quot;</span>)))))))
<span class="ot">&gt;</span>           (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;len&quot;</span>))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> eMap <span class="fu">=</span> <span class="dt">ERec</span> (<span class="dt">EV</span> <span class="st">&quot;map&quot;</span>) 
<span class="ot">&gt;</span>           (<span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;f&quot;</span>) <span class="fu">$</span> <span class="dt">EAbs</span> (<span class="dt">EV</span> <span class="st">&quot;xs&quot;</span>) <span class="fu">$</span> 
<span class="ot">&gt;</span>              eIf (<span class="dt">EIsNil</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;xs&quot;</span>))) 
<span class="ot">&gt;</span>                  <span class="dt">ENil</span>
<span class="ot">&gt;</span>                  (<span class="dt">ECons</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;f&quot;</span>) <span class="ot">`EApp`</span> (eHd <span class="ot">`EApp`</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;xs&quot;</span>))))
<span class="ot">&gt;</span>                         ((<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;map&quot;</span>) <span class="ot">`EApp`</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;f&quot;</span>))) <span class="ot">`EApp`</span>
<span class="ot">&gt;</span>                         (eTl <span class="ot">`EApp`</span> (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;xs&quot;</span>))))))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>           (<span class="dt">EVbl</span> (<span class="dt">EV</span> <span class="st">&quot;map&quot;</span>))</code></pre></div>
<p>have the types equivalent to</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> tLen  <span class="fu">=</span> <span class="dt">Forall</span> [<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>] <span class="fu">$</span> ((<span class="dt">TList</span> (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>))) <span class="ot">`TArr`</span> <span class="dt">TInt</span>)
<span class="ot">&gt;</span> tMap  <span class="fu">=</span> <span class="dt">Forall</span> [<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TV</span> <span class="st">&quot;b&quot;</span>] <span class="fu">$</span> tArrs [<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>) <span class="ot">`TArr`</span> <span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;b&quot;</span>)
<span class="ot">&gt;</span>                                         ,<span class="dt">TList</span> (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;a&quot;</span>))
<span class="ot">&gt;</span>                                         ,<span class="dt">TList</span> (<span class="dt">TVbl</span> (<span class="dt">TV</span> <span class="st">&quot;b&quot;</span>))]</code></pre></div>
<h2 id="appendix-code-for-type-inference-from-lecture">Appendix: Code for Type Inference from Lecture</h2>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Exp</span>     <span class="fu">=</span>  <span class="dt">EVbl</span> <span class="dt">EVbl</span> 
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">ELit</span> <span class="dt">Lit</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">EApp</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">EAbs</span> <span class="dt">EVbl</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">ELet</span> <span class="dt">EVbl</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
<span class="ot">&gt;</span>                                   <span class="co">-- part (a)</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">Exp</span> <span class="ot">`ECom`</span> <span class="dt">Exp</span>    <span class="co">-- Construct a pair of two expressions</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">EFst</span>  <span class="dt">Exp</span>         <span class="co">-- Extract the first  element of a pair</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">ESnd</span>  <span class="dt">Exp</span>         <span class="co">-- Extract the second element of a pair</span>
<span class="ot">&gt;</span>                                   <span class="co">-- part (b)</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">ENil</span>              <span class="co">-- empty list</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">Exp</span> <span class="ot">`ECons`</span> <span class="dt">Exp</span>   <span class="co">-- head &quot;cons-ed&quot; to a tail</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">EIsNil</span> <span class="dt">Exp</span>        <span class="co">-- test if a list is empty</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">EDcons</span> <span class="dt">Exp</span>        <span class="co">-- return a pair of (head, tail) of (non-empty) list</span>
<span class="ot">&gt;</span>                                   <span class="co">-- part (c)</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">ERec</span> <span class="dt">EVbl</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="co">-- ERec x e1 e2 is like Let x e1 e2 but x can appear in e1</span>
<span class="ot">&gt;</span>              <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">EVbl</span> <span class="fu">=</span> <span class="dt">EV</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Lit</span>     <span class="fu">=</span>  <span class="dt">LInt</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">LBool</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span>              <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Type</span>    <span class="fu">=</span>  <span class="dt">TVbl</span> <span class="dt">TVbl</span> 
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">TInt</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">TBool</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">Type</span> <span class="ot">`TArr`</span> <span class="dt">Type</span>
<span class="ot">&gt;</span>                                    <span class="co">-- part (a)</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">Type</span> <span class="ot">`TCom`</span> <span class="dt">Type</span>   <span class="co">-- Pair of two types</span>
<span class="ot">&gt;</span>                                    <span class="co">-- part (b)</span>
<span class="ot">&gt;</span>              <span class="fu">|</span>  <span class="dt">TList</span> <span class="dt">Type</span>         <span class="co">-- TList t is a list of t values </span>
<span class="ot">&gt;</span>              <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">TVbl</span> <span class="fu">=</span> <span class="dt">TV</span> <span class="dt">String</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Scheme</span>  <span class="fu">=</span>  <span class="dt">Forall</span> [<span class="dt">TVbl</span>] <span class="dt">Type</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">TypeEnv</span> <span class="fu">=</span> <span class="dt">TypeEnv</span> (<span class="dt">Map.Map</span> <span class="dt">EVbl</span> <span class="dt">Scheme</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> (\\)<span class="ot"> ::</span> <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> (<span class="dt">EVbl</span>, <span class="dt">Scheme</span>) <span class="ot">-&gt;</span> <span class="dt">TypeEnv</span>
<span class="ot">&gt;</span> (<span class="dt">TypeEnv</span> env) \\ (x, s) <span class="fu">=</span>  <span class="dt">TypeEnv</span> <span class="fu">$</span> Map.insert x s env
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Subst</span> <span class="fu">=</span> <span class="dt">Map.Map</span> <span class="dt">TVbl</span> <span class="dt">Type</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">Substitutable</span> a <span class="kw">where</span> 
<span class="ot">&gt;   apply     ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;   freeTvars ::</span> a <span class="ot">-&gt;</span> <span class="dt">Set.Set</span> <span class="dt">TVbl</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Substitutable</span> <span class="dt">Type</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   apply _  <span class="dt">TInt</span>            <span class="fu">=</span> <span class="dt">TInt</span>
<span class="ot">&gt;</span>   apply _  <span class="dt">TBool</span>           <span class="fu">=</span> <span class="dt">TBool</span>
<span class="ot">&gt;</span>   apply su t<span class="fu">@</span>(<span class="dt">TVbl</span> a)      <span class="fu">=</span> Map.findWithDefault t a su 
<span class="ot">&gt;</span>   apply su (t1 <span class="ot">`TArr`</span> t2)  <span class="fu">=</span> apply su t1 <span class="ot">`TArr`</span> apply su t2
<span class="ot">&gt;</span>   apply su (t1 <span class="ot">`TCom`</span> t2)  <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span>   apply su (<span class="dt">TList</span> t)       <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   freeTvars <span class="dt">TInt</span>           <span class="fu">=</span>  Set.empty
<span class="ot">&gt;</span>   freeTvars <span class="dt">TBool</span>          <span class="fu">=</span>  Set.empty
<span class="ot">&gt;</span>   freeTvars (<span class="dt">TVbl</span> a)       <span class="fu">=</span>  Set.singleton a
<span class="ot">&gt;</span>   freeTvars (t1 <span class="ot">`TArr`</span> t2) <span class="fu">=</span>  freeTvars t1 <span class="ot">`Set.union`</span> freeTvars t2
<span class="ot">&gt;</span>   freeTvars (t1 <span class="ot">`TCom`</span> t2) <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span>   freeTvars (<span class="dt">TList</span> t)      <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Substitutable</span> <span class="dt">Scheme</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   apply s (<span class="dt">Forall</span> as t)   <span class="fu">=</span> <span class="dt">Forall</span> as <span class="fu">$</span> apply s' t 
<span class="ot">&gt;</span>                             <span class="kw">where</span> s' <span class="fu">=</span> foldr Map.delete s as 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span>   freeTvars (<span class="dt">Forall</span> as t) <span class="fu">=</span> (freeTvars t) <span class="ot">`Set.difference`</span> (Set.fromList as)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Substitutable</span> a <span class="ot">=&gt;</span> <span class="dt">Substitutable</span> [a] <span class="kw">where</span>
<span class="ot">&gt;</span>   apply     <span class="fu">=</span> map <span class="fu">.</span> apply
<span class="ot">&gt;</span>   freeTvars <span class="fu">=</span> foldr Set.union Set.empty <span class="fu">.</span> map freeTvars
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Substitutable</span> <span class="dt">TypeEnv</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   apply s   (<span class="dt">TypeEnv</span> env) <span class="fu">=</span>  <span class="dt">TypeEnv</span>   <span class="fu">$</span> Map.map (apply s) env
<span class="ot">&gt;</span>   freeTvars (<span class="dt">TypeEnv</span> env) <span class="fu">=</span>  freeTvars <span class="fu">$</span> Map.elems env
<span class="ot">&gt;</span> 
<span class="ot">&gt; empSubst  ::</span>  <span class="dt">Subst</span>
<span class="ot">&gt;</span> empSubst  <span class="fu">=</span>   Map.empty
<span class="ot">&gt;</span> 
<span class="ot">&gt; after         ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span>
<span class="ot">&gt;</span> su1 <span class="ot">`after`</span> su2 <span class="fu">=</span> (Map.map (apply su1) su2) <span class="ot">`Map.union`</span> su1
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> mgu (l <span class="ot">`TCom`</span> r) (l' <span class="ot">`TCom`</span> r')  <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> mgu (<span class="dt">TList</span> t1) (<span class="dt">TList</span> t2)        <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> mgu (l <span class="ot">`TArr`</span> r) (l' <span class="ot">`TArr`</span> r')  <span class="fu">=</span> <span class="kw">do</span>  s1 <span class="ot">&lt;-</span> mgu l l'
<span class="ot">&gt;</span>                                        s2 <span class="ot">&lt;-</span> mgu (apply s1 r) (apply s1 r')
<span class="ot">&gt;</span>                                        return (s2 <span class="ot">`after`</span> s1)
<span class="ot">&gt;</span> mgu (<span class="dt">TVbl</span> a) t                   <span class="fu">=</span> varAsgn a t
<span class="ot">&gt;</span> mgu t (<span class="dt">TVbl</span> a)                   <span class="fu">=</span> varAsgn a t
<span class="ot">&gt;</span> mgu <span class="dt">TInt</span> <span class="dt">TInt</span>                    <span class="fu">=</span> return empSubst
<span class="ot">&gt;</span> mgu <span class="dt">TBool</span> <span class="dt">TBool</span>                  <span class="fu">=</span> return empSubst
<span class="ot">&gt;</span> mgu t1 t2                        <span class="fu">=</span> throwError <span class="fu">$</span> <span class="st">&quot;types do not unify: &quot;</span> <span class="fu">++</span> show t1 <span class="fu">++</span> <span class="st">&quot; vs. &quot;</span> <span class="fu">++</span> show t2
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> varAsgn a t 
<span class="ot">&gt;</span>   <span class="fu">|</span> t <span class="fu">==</span> <span class="dt">TVbl</span> a                  <span class="fu">=</span>  return empSubst
<span class="ot">&gt;</span>   <span class="fu">|</span> a <span class="ot">`Set.member`</span> (freeTvars t) <span class="fu">=</span>  throwError <span class="fu">$</span> <span class="st">&quot;occur check fails: &quot;</span> <span class="fu">++</span> show a <span class="fu">++</span> <span class="st">&quot; in &quot;</span> <span class="fu">++</span> show t
<span class="ot">&gt;</span>   <span class="fu">|</span> otherwise                    <span class="fu">=</span>  return <span class="fu">$</span> Map.singleton a t
<span class="ot">&gt;</span> 
<span class="ot">&gt; generalize        ::</span>  <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Scheme</span>
<span class="ot">&gt;</span> generalize env t  <span class="fu">=</span>   <span class="dt">Forall</span> as t
<span class="ot">&gt;</span>   <span class="kw">where</span> as <span class="fu">=</span> Set.toList <span class="fu">$</span> (freeTvars t) <span class="ot">`Set.difference`</span> (freeTvars env)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">TIState</span> <span class="fu">=</span> <span class="dt">TIState</span> {<span class="ot"> count ::</span> <span class="dt">Int</span> }
<span class="ot">&gt;</span> 
<span class="ot">&gt; fresh ::</span> (<span class="dt">MonadState</span> <span class="dt">TIState</span> m) <span class="ot">=&gt;</span> m <span class="dt">Int</span>
<span class="ot">&gt;</span> fresh <span class="fu">=</span> <span class="kw">do</span> s     <span class="ot">&lt;-</span> get
<span class="ot">&gt;</span>            <span class="kw">let</span> n <span class="fu">=</span> count s
<span class="ot">&gt;</span>            put   <span class="fu">$</span> s { count <span class="fu">=</span> n <span class="fu">+</span> <span class="dv">1</span> }
<span class="ot">&gt;</span>            return n
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> freshTVbl prefix <span class="fu">=</span> fresh <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> <span class="dt">TVbl</span> <span class="fu">.</span> <span class="dt">TV</span> <span class="fu">.</span> (prefix <span class="fu">++</span>) <span class="fu">.</span> show
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> instantiate (<span class="dt">Forall</span> as t) <span class="fu">=</span> <span class="kw">do</span> as' <span class="ot">&lt;-</span> mapM (\ _ <span class="ot">-&gt;</span> freshTVbl <span class="st">&quot;a&quot;</span>) as 
<span class="ot">&gt;</span>                                <span class="kw">let</span> s <span class="fu">=</span> Map.fromList <span class="fu">$</span> zip as as'
<span class="ot">&gt;</span>                                return <span class="fu">$</span> apply s t
<span class="ot">&gt;</span> 
<span class="ot">&gt; ti ::</span>  (<span class="dt">MonadState</span> <span class="dt">TIState</span> m, <span class="dt">MonadError</span> <span class="dt">String</span> m) <span class="ot">=&gt;</span> 
<span class="ot">&gt;</span>        <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> m (<span class="dt">Subst</span>, <span class="dt">Type</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> ti env (<span class="dt">ELit</span> (<span class="dt">LInt</span> _))  <span class="fu">=</span> return (empSubst, <span class="dt">TInt</span>)
<span class="ot">&gt;</span> ti env (<span class="dt">ELit</span> (<span class="dt">LBool</span> _)) <span class="fu">=</span> return (empSubst, <span class="dt">TBool</span>)
<span class="ot">&gt;</span> ti (<span class="dt">TypeEnv</span> env) (<span class="dt">EVbl</span> x) <span class="fu">=</span> 
<span class="ot">&gt;</span>     <span class="kw">case</span> Map.lookup x env <span class="kw">of</span>
<span class="ot">&gt;</span>        <span class="dt">Nothing</span>   <span class="ot">-&gt;</span>  throwError <span class="fu">$</span> <span class="st">&quot;unbound variable: &quot;</span> <span class="fu">++</span> show x
<span class="ot">&gt;</span>        <span class="dt">Just</span> s    <span class="ot">-&gt;</span>  instantiate s <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> (,) empSubst 
<span class="ot">&gt;</span> ti env (<span class="dt">EAbs</span> x e) <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="kw">do</span>  tv       <span class="ot">&lt;-</span> freshTVbl <span class="st">&quot;a&quot;</span>
<span class="ot">&gt;</span>         <span class="kw">let</span> env' <span class="fu">=</span> env \\ (x, <span class="dt">Forall</span> [] tv)
<span class="ot">&gt;</span>         (s1, t1) <span class="ot">&lt;-</span> ti env' e
<span class="ot">&gt;</span>         return (s1, (apply s1 tv) <span class="ot">`TArr`</span> t1)
<span class="ot">&gt;</span> ti env (<span class="dt">EApp</span> e1 e2) <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="kw">do</span>  tv       <span class="ot">&lt;-</span> freshTVbl <span class="st">&quot;a&quot;</span>
<span class="ot">&gt;</span>         (s1, t1) <span class="ot">&lt;-</span> ti env e1
<span class="ot">&gt;</span>         (s2, t2) <span class="ot">&lt;-</span> ti (apply s1 env) e2
<span class="ot">&gt;</span>         s3       <span class="ot">&lt;-</span> mgu (apply s2 t1) (<span class="dt">TArr</span> t2 tv)
<span class="ot">&gt;</span>         return (s3 <span class="ot">`after`</span> s2 <span class="ot">`after`</span> s1, apply s3 tv)
<span class="ot">&gt;</span> ti env (<span class="dt">ELet</span> x e1 e2) <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="kw">do</span>  (s1, t1) <span class="ot">&lt;-</span> ti env e1
<span class="ot">&gt;</span>         <span class="kw">let</span> t'   <span class="fu">=</span> generalize (apply s1 env) t1
<span class="ot">&gt;</span>             env' <span class="fu">=</span> env \\ (x, t')
<span class="ot">&gt;</span>         (s2, t2) <span class="ot">&lt;-</span> ti (apply s1 env') e2
<span class="ot">&gt;</span>         return (s2 <span class="ot">`after`</span> s1, t2)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> ti env (e1 <span class="ot">`ECom`</span> e2) <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> ti env (<span class="dt">EFst</span> e)       <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> ti env (<span class="dt">ESnd</span> e)       <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> ti env <span class="dt">ENil</span>            <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> ti env (e1 <span class="ot">`ECons`</span> e2) <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> ti env (<span class="dt">EIsNil</span> e)      <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> ti env (<span class="dt">EDcons</span> e)      <span class="fu">=</span> error <span class="st">&quot;TDB&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> ti env (<span class="dt">ERec</span> x e1 e2)  <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> ti_top env e <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="kw">do</span>  (s, t) <span class="ot">&lt;-</span> ti env e
<span class="ot">&gt;</span>         return  <span class="fu">$</span> generalize (apply s env) (apply s t)
<span class="ot">&gt;</span> 
<span class="ot">&gt; typeInference ::</span> <span class="dt">TypeEnv</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Scheme</span> 
<span class="ot">&gt;</span> typeInference env e <span class="fu">=</span> res
<span class="ot">&gt;</span>   <span class="kw">where</span> act <span class="fu">=</span> ti_top env e
<span class="ot">&gt;</span>         res <span class="fu">=</span> evalState (runErrorT act) s0 
<span class="ot">&gt;</span>         s0  <span class="fu">=</span> <span class="dt">TIState</span> { count <span class="fu">=</span> <span class="dv">0</span> }
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt; test ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> test e <span class="fu">=</span> <span class="kw">case</span> typeInference (<span class="dt">TypeEnv</span> Map.empty) e <span class="kw">of</span>
<span class="ot">&gt;</span>            <span class="dt">Left</span> err  <span class="ot">-&gt;</span>  putStrLn <span class="fu">$</span> <span class="st">&quot;error: &quot;</span> <span class="fu">++</span> err
<span class="ot">&gt;</span>            <span class="dt">Right</span> t   <span class="ot">-&gt;</span>  putStrLn <span class="fu">$</span> show e <span class="fu">++</span> <span class="st">&quot; :: &quot;</span> <span class="fu">++</span> show t
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">TVbl</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   showsPrec _ x <span class="fu">=</span> shows (prTVbl x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> prTVbl (<span class="dt">TV</span> a) <span class="fu">=</span> PP.text a
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Type</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   showsPrec _ x <span class="fu">=</span> shows (prType x)
<span class="ot">&gt;</span> 
<span class="ot">&gt; prType             ::</span>  <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span>
<span class="ot">&gt;</span> prType (<span class="dt">TVbl</span> a)    <span class="fu">=</span>   prTVbl a
<span class="ot">&gt;</span> prType <span class="dt">TInt</span>        <span class="fu">=</span>   PP.text <span class="st">&quot;Int&quot;</span>
<span class="ot">&gt;</span> prType <span class="dt">TBool</span>       <span class="fu">=</span>   PP.text <span class="st">&quot;Bool&quot;</span>
<span class="ot">&gt;</span> prType (<span class="dt">TArr</span> t s)  <span class="fu">=</span>   prParenType t <span class="fu">PP.&lt;+&gt;</span> PP.text <span class="st">&quot;-&gt;&quot;</span> <span class="fu">PP.&lt;+&gt;</span> prType s
<span class="ot">&gt;</span> prType _           <span class="fu">=</span>   PP.text <span class="st">&quot;FINAL optional&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; prParenType     ::</span>  <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span>
<span class="ot">&gt;</span> prParenType  t  <span class="fu">=</span>   <span class="kw">case</span> t <span class="kw">of</span>
<span class="ot">&gt;</span>                       <span class="dt">TArr</span> _ _  <span class="ot">-&gt;</span> PP.parens (prType t)
<span class="ot">&gt;</span>                       _         <span class="ot">-&gt;</span> prType t
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">EVbl</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   showsPrec _ x <span class="fu">=</span> shows (prEVbl x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Exp</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   showsPrec _ x <span class="fu">=</span> shows (prExp x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> prEVbl (<span class="dt">EV</span> x)          <span class="fu">=</span> PP.text x
<span class="ot">&gt;</span> 
<span class="ot">&gt; prExp                  ::</span>  <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span>
<span class="ot">&gt;</span> prExp (<span class="dt">EVbl</span> x)         <span class="fu">=</span>   prEVbl x
<span class="ot">&gt;</span> prExp (<span class="dt">ELit</span> lit)       <span class="fu">=</span>   prLit lit
<span class="ot">&gt;</span> prExp (<span class="dt">ELet</span> x b body)  <span class="fu">=</span>   PP.text <span class="st">&quot;let&quot;</span> <span class="fu">PP.&lt;+&gt;</span> 
<span class="ot">&gt;</span>                            prEVbl x <span class="fu">PP.&lt;+&gt;</span> PP.text <span class="st">&quot;=&quot;</span> <span class="fu">PP.&lt;+&gt;</span>
<span class="ot">&gt;</span>                            prExp b <span class="fu">PP.&lt;+&gt;</span> PP.text <span class="st">&quot;in&quot;</span> <span class="fu">PP.$$</span>
<span class="ot">&gt;</span>                            PP.nest <span class="dv">2</span> (prExp body)
<span class="ot">&gt;</span> prExp (<span class="dt">EApp</span> e1 e2)     <span class="fu">=</span>   prExp e1 <span class="fu">PP.&lt;+&gt;</span> prParenExp e2
<span class="ot">&gt;</span> prExp (<span class="dt">EAbs</span> x e)       <span class="fu">=</span>   PP.char <span class="ch">'\\'</span> <span class="fu">PP.&lt;+&gt;</span> prEVbl x <span class="fu">PP.&lt;+&gt;</span>
<span class="ot">&gt;</span>                            PP.text <span class="st">&quot;-&gt;&quot;</span> <span class="fu">PP.&lt;+&gt;</span>
<span class="ot">&gt;</span>                            prExp e
<span class="ot">&gt;</span> prExp _                <span class="fu">=</span>   PP.text <span class="st">&quot;FINAL optional&quot;</span>
<span class="ot">&gt;</span>                                                                    
<span class="ot">&gt;</span> 
<span class="ot">&gt; prParenExp    ::</span>  <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span>
<span class="ot">&gt;</span> prParenExp t  <span class="fu">=</span>   <span class="kw">case</span> t <span class="kw">of</span>
<span class="ot">&gt;</span>                     <span class="dt">ELet</span> _ _ _  <span class="ot">-&gt;</span> PP.parens (prExp t)
<span class="ot">&gt;</span>                     <span class="dt">EApp</span> _ _    <span class="ot">-&gt;</span> PP.parens (prExp t)
<span class="ot">&gt;</span>                     <span class="dt">EAbs</span> _ _    <span class="ot">-&gt;</span> PP.parens (prExp t)
<span class="ot">&gt;</span>                     _           <span class="ot">-&gt;</span> prExp t
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Lit</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     showsPrec _ x <span class="fu">=</span> shows (prLit x)
<span class="ot">&gt;</span> 
<span class="ot">&gt; prLit            ::</span>  <span class="dt">Lit</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span>
<span class="ot">&gt;</span> prLit (<span class="dt">LInt</span> i)   <span class="fu">=</span>   PP.integer i
<span class="ot">&gt;</span> prLit (<span class="dt">LBool</span> b)  <span class="fu">=</span>   <span class="kw">if</span> b <span class="kw">then</span> PP.text <span class="st">&quot;True&quot;</span> <span class="kw">else</span> PP.text <span class="st">&quot;False&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Scheme</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     showsPrec _ x <span class="fu">=</span> shows (prScheme x)
<span class="ot">&gt;</span> 
<span class="ot">&gt; prScheme                ::</span>  <span class="dt">Scheme</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span>
<span class="ot">&gt;</span> prScheme (<span class="dt">Forall</span> as t)  <span class="fu">=</span>   PP.text <span class="st">&quot;All&quot;</span> <span class="fu">PP.&lt;+&gt;</span>
<span class="ot">&gt;</span>                             PP.hcat (PP.punctuate PP.comma (map prTVbl as))
<span class="ot">&gt;</span>                             <span class="fu">PP.&lt;&gt;</span> PP.text <span class="st">&quot;.&quot;</span> <span class="fu">PP.&lt;+&gt;</span> prType t</code></pre></div>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
