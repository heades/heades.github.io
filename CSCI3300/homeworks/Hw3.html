<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>CSCI:3300 - Homework</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax-rj.css" />                
    </head>
    <body>
      
      <h1>CSCI:3300 - Homework </h1>
        <div id="navigation">
        <a href="../index.html">Home</a>
        <a href="../grades.html">Grading</a>
		<a href="../lectures.html">Lectures</a>
	    <a href="../assignments.html">Assignments</a>
	    <a href="../links.html">Links</a>
        <a href="https://piazza.com/class/i4kkvjdaoqj7aj#">Piazza</a>
        </div>
       
	<br />
	<br />
	<h1 id="preliminaries">Preliminaries</h1>
<p>Before starting this part of the assignment,</p>
<ol style="list-style-type: decimal">
<li>Install the following packages</li>
</ol>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> cabal install quickcheck</code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Learn to read the <a href="http://hackage.haskell.org">documentation</a></li>
</ol>
<p>To complete this homework, download <a href="../homeworks/Hw3.lhs">this file</a> as plain text and answer each question, filling in code where it says <code>&quot;TODO&quot;</code>. Your code must typecheck against the given type signatures. Feel free to add your own tests to this file to exercise the functions you write. Submit your homework by sending this file, filled in appropriately, to cse230@goto.ucsd.edu with the subject “HW3”; you will receive a confirmation email after submitting. Please note that this address is unmonitored; if you have any questions about the assignment, post to Piazza.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TypeSynonymInstances, FlexibleContexts, NoMonomorphismRestriction, OverlappingInstances, FlexibleInstances #-}</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Hw3</span> <span class="kw">where</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.State</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Error</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad.Writer</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span> <span class="kw">hiding</span> ((===))
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Control.Monad</span> (forM, forM_)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span> (transpose, intercalate)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> quickCheckN n <span class="fu">=</span> quickCheckWith <span class="fu">$</span> stdArgs { maxSuccess <span class="fu">=</span> n}</code></pre></div>
<h1 id="problem-0-all-about-you">Problem 0: All About You</h1>
<p>Tell us your name, email and student ID, by replacing the respective strings below</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> myName  <span class="fu">=</span> <span class="st">&quot;Write Your Name  Here&quot;</span>
<span class="ot">&gt;</span> myEmail <span class="fu">=</span> <span class="st">&quot;Write Your Email Here&quot;</span>
<span class="ot">&gt;</span> mySID   <span class="fu">=</span> <span class="st">&quot;Write Your SID   Here&quot;</span></code></pre></div>
<h1 id="problem-1-binary-search-trees-revisited">Problem 1: Binary Search Trees Revisited</h1>
<p>Recall the old type of binary search trees from <a href="../homeworks/Hw2.html">HW2</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">BST</span> k v <span class="fu">=</span> <span class="dt">Emp</span> 
<span class="ot">&gt;</span>              <span class="fu">|</span> <span class="dt">Bind</span> k v (<span class="dt">BST</span> k v) (<span class="dt">BST</span> k v) 
<span class="ot">&gt;</span>              <span class="kw">deriving</span> (<span class="dt">Show</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; toBinds ::</span>  <span class="dt">BST</span> t t1 <span class="ot">-&gt;</span> [(t, t1)]
<span class="ot">&gt;</span> toBinds <span class="dt">Emp</span>            <span class="fu">=</span> []
<span class="ot">&gt;</span> toBinds (<span class="dt">Bind</span> k v l r) <span class="fu">=</span> toBinds l <span class="fu">++</span> [(k,v)] <span class="fu">++</span> toBinds r</code></pre></div>
<p>The following function tests whether a tree satisfies the binary-search-order invariant.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isBSO ::</span>  <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">BST</span> a b <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isBSO <span class="dt">Emp</span>            <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> isBSO (<span class="dt">Bind</span> k v l r) <span class="fu">=</span> all (<span class="fu">&lt;</span> k) lks <span class="fu">&amp;&amp;</span> all (k <span class="fu">&lt;</span>) rks <span class="fu">&amp;&amp;</span> isBSO l <span class="fu">&amp;&amp;</span> isBSO r
<span class="ot">&gt;</span>   <span class="kw">where</span> lks <span class="fu">=</span> map fst <span class="fu">$</span> toBinds l
<span class="ot">&gt;</span>         rks <span class="fu">=</span> map fst <span class="fu">$</span> toBinds r</code></pre></div>
<p>Finally, to test your implementation, we will define a type of operations over trees</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">BSTop</span> k v <span class="fu">=</span> <span class="dt">BSTadd</span> k v <span class="fu">|</span> <span class="dt">BSTdel</span> k 
<span class="ot">&gt;</span>                  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>and a function that constructs a tree from a sequence of operations</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; ofBSTops ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> [<span class="dt">BSTop</span> k v] <span class="ot">-&gt;</span> <span class="dt">BST</span> k v
<span class="ot">&gt;</span> ofBSTops    <span class="fu">=</span> foldr doOp <span class="dt">Emp</span>
<span class="ot">&gt;</span>   <span class="kw">where</span> doOp (<span class="dt">BSTadd</span> k v) <span class="fu">=</span> bstInsert k v 
<span class="ot">&gt;</span>         doOp (<span class="dt">BSTdel</span> k)   <span class="fu">=</span> bstDelete k </code></pre></div>
<p>and that constructs a reference <code>Map</code> from a sequence of operations</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; mapOfBSTops ::</span>  <span class="dt">Ord</span> k <span class="ot">=&gt;</span> [<span class="dt">BSTop</span> k a] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> k a
<span class="ot">&gt;</span> mapOfBSTops <span class="fu">=</span> foldr doOp Map.empty 
<span class="ot">&gt;</span>   <span class="kw">where</span> doOp (<span class="dt">BSTadd</span> k v) <span class="fu">=</span> Map.insert k v
<span class="ot">&gt;</span>         doOp (<span class="dt">BSTdel</span> k)   <span class="fu">=</span> Map.delete k</code></pre></div>
<p>and functions that generate an arbitrary BST operations</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; keys ::</span> [<span class="dt">Int</span>] 
<span class="ot">&gt;</span> keys <span class="fu">=</span> [<span class="dv">0</span><span class="fu">..</span><span class="dv">10</span>]
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> genBSTadd, genBSTdel,<span class="ot"> genBSTop ::</span>  <span class="dt">Gen</span> (<span class="dt">BSTop</span> <span class="dt">Int</span> <span class="dt">Char</span>)
<span class="ot">&gt;</span> genBSTadd <span class="fu">=</span> liftM2 <span class="dt">BSTadd</span> (elements keys) (elements [<span class="ch">'a'</span><span class="fu">..</span><span class="ch">'z'</span>])
<span class="ot">&gt;</span> genBSTdel <span class="fu">=</span> liftM <span class="dt">BSTdel</span> (elements keys)
<span class="ot">&gt;</span> genBSTop  <span class="fu">=</span> frequency [(<span class="dv">5</span>, genBSTadd), (<span class="dv">1</span>, genBSTdel)] </code></pre></div>
<h2 id="a-insertion">(a) Insertion</h2>
<p>Write an insertion function</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; bstInsert ::</span> (<span class="dt">Ord</span> k) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">BST</span> k v <span class="ot">-&gt;</span> <span class="dt">BST</span> k v
<span class="ot">&gt;</span> bstInsert <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span></code></pre></div>
<p>such that <code>bstInsert k v t</code> inserts a key <code>k</code> with value <code>v</code> into the tree <code>t</code>. If <code>k</code> already exists in the input tree, then its value should be <em>replaced</em> with <code>v</code>. When you are done, your code should satisfy the following QC properties.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_insert_bso ::</span> <span class="dt">Property</span>
<span class="ot">&gt;</span> prop_insert_bso <span class="fu">=</span> forAll (listOf genBSTadd) <span class="fu">$</span> \ops <span class="ot">-&gt;</span> 
<span class="ot">&gt;</span>                     isBSO (ofBSTops ops)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> prop_insert_map <span class="fu">=</span> forAll (listOf genBSTadd) <span class="fu">$</span> \ops <span class="ot">-&gt;</span> 
<span class="ot">&gt;</span>                     toBinds (ofBSTops ops) <span class="fu">==</span> Map.toAscList (mapOfBSTops ops)</code></pre></div>
<h2 id="b-deletion">(b) Deletion</h2>
<p>Write a deletion function for BSTs of this type:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; bstDelete ::</span> (<span class="dt">Ord</span> k) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">BST</span> k v <span class="ot">-&gt;</span> <span class="dt">BST</span> k v
<span class="ot">&gt;</span> bstDelete k t <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span></code></pre></div>
<p>such that <code>bstDelete k t</code> removes the key <code>k</code> from the tree <code>t</code>. If <code>k</code> is absent from the input tree, then the tree is returned unchanged as the output. When you are done, your code should satisfy the following QC properties.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_delete_bso ::</span> <span class="dt">Property</span>
<span class="ot">&gt;</span> prop_delete_bso <span class="fu">=</span> forAll (listOf genBSTop) <span class="fu">$</span> \ops <span class="ot">-&gt;</span> 
<span class="ot">&gt;</span>                     isBSO (ofBSTops ops)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> prop_delete_map <span class="fu">=</span> forAll (listOf genBSTop) <span class="fu">$</span> \ops <span class="ot">-&gt;</span> 
<span class="ot">&gt;</span>                     toBinds (ofBSTops ops) <span class="fu">==</span> Map.toAscList (mapOfBSTops ops)</code></pre></div>
<h2 id="c-balanced-trees">(c) Balanced Trees</h2>
<p>The following function determines the <code>height</code> of a BST</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> height (<span class="dt">Bind</span> _ _ l r) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> max (height l) (height r)
<span class="ot">&gt;</span> height <span class="dt">Emp</span>            <span class="fu">=</span> <span class="dv">0</span></code></pre></div>
<p>We say that a tree is <em>balanced</em> if</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> isBal (<span class="dt">Bind</span> _ _ l r) <span class="fu">=</span> isBal l <span class="fu">&amp;&amp;</span> isBal r <span class="fu">&amp;&amp;</span> abs (height l <span class="fu">-</span> height r) <span class="fu">&lt;=</span> <span class="dv">2</span>
<span class="ot">&gt;</span> isBal <span class="dt">Emp</span>            <span class="fu">=</span> <span class="dt">True</span></code></pre></div>
<p>Write a balanced tree generator</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; genBal ::</span> <span class="dt">Gen</span> (<span class="dt">BST</span> <span class="dt">Int</span> <span class="dt">Char</span>)
<span class="ot">&gt;</span> genBal <span class="fu">=</span> error <span class="st">&quot;TBD&quot;</span></code></pre></div>
<p>such that</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> prop_genBal <span class="fu">=</span> forAll genBal isBal</code></pre></div>
<ol start="4" style="list-style-type: lower-alpha">
<li>Height Balancing (** Hard **) ———————————</li>
</ol>
<p>Rig it so that your insert and delete functions <em>also</em> create balanced trees. That is, they satisfy the properties</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_insert_bal ::</span>  <span class="dt">Property</span>
<span class="ot">&gt;</span> prop_insert_bal <span class="fu">=</span> forAll (listOf genBSTadd) <span class="fu">$</span> isBal <span class="fu">.</span> ofBSTops 
<span class="ot">&gt;</span> 
<span class="ot">&gt; prop_delete_bal ::</span>  <span class="dt">Property</span>
<span class="ot">&gt;</span> prop_delete_bal <span class="fu">=</span> forAll (listOf genBSTop) <span class="fu">$</span> isBal <span class="fu">.</span> ofBSTops</code></pre></div>
<h1 id="problem-2-circuit-testing">Problem 2: Circuit Testing</h1>
<p>Credit: <a href="http://www.cis.upenn.edu/~bcpierce/courses/552-2008/resources/circuits.hs">UPenn CIS552</a></p>
<p>For this problem, you will look at a model of circuits in Haskell.</p>
<h2 id="signals">Signals</h2>
<p>A <em>signal</em> is a list of booleans.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Signal</span> <span class="fu">=</span> <span class="dt">Sig</span> [<span class="dt">Bool</span>]</code></pre></div>
<p>By convention, all signals are infinite. We write a bunch of lifting functions that lift boolean operators over signals.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; lift0 ::</span>  <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> lift0 a <span class="fu">=</span> <span class="dt">Sig</span> <span class="fu">$</span> repeat a
<span class="ot">&gt;</span> 
<span class="ot">&gt; lift1 ::</span>  (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span> <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> lift1 f (<span class="dt">Sig</span> s) <span class="fu">=</span> <span class="dt">Sig</span> <span class="fu">$</span> map f s
<span class="ot">&gt;</span> 
<span class="ot">&gt; lift2 ::</span>  (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> lift2 f (<span class="dt">Sig</span> xs, <span class="dt">Sig</span> ys) <span class="fu">=</span> <span class="dt">Sig</span> <span class="fu">$</span> zipWith f xs ys
<span class="ot">&gt;</span> 
<span class="ot">&gt; lift22 ::</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>)) <span class="ot">-&gt;</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> (<span class="dt">Signal</span>,<span class="dt">Signal</span>)
<span class="ot">&gt;</span> lift22 f (<span class="dt">Sig</span> xs, <span class="dt">Sig</span> ys) <span class="fu">=</span> 
<span class="ot">&gt;</span>   <span class="kw">let</span> (zs1,zs2) <span class="fu">=</span> unzip (zipWith f xs ys)
<span class="ot">&gt;</span>   <span class="kw">in</span> (<span class="dt">Sig</span> zs1, <span class="dt">Sig</span> zs2) 
<span class="ot">&gt;</span> 
<span class="ot">&gt; lift3 ::</span> (<span class="dt">Bool</span><span class="ot">-&gt;</span><span class="dt">Bool</span><span class="ot">-&gt;</span><span class="dt">Bool</span><span class="ot">-&gt;</span><span class="dt">Bool</span>) <span class="ot">-&gt;</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> lift3 f (<span class="dt">Sig</span> xs, <span class="dt">Sig</span> ys, <span class="dt">Sig</span> zs) <span class="fu">=</span> <span class="dt">Sig</span> <span class="fu">$</span> zipWith3 f xs ys zs</code></pre></div>
<h2 id="simulation">Simulation</h2>
<p>Next, we have some helpers that can help us simulate a circuit by showing how it behaves over time. For testing or printing, we truncate a signal to a short prefix</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> truncatedSignalSize <span class="fu">=</span> <span class="dv">20</span>
<span class="ot">&gt;</span> truncateSig bs <span class="fu">=</span> take truncatedSignalSize bs
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Signal</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   show (<span class="dt">Sig</span> s) <span class="fu">=</span> show (truncateSig s) <span class="fu">++</span> <span class="st">&quot;...&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; trace ::</span> [(<span class="dt">String</span>, <span class="dt">Signal</span>)] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> trace desc count <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>   putStrLn   <span class="fu">$</span> intercalate <span class="st">&quot; &quot;</span> names
<span class="ot">&gt;</span>   forM_ rows <span class="fu">$</span> putStrLn <span class="fu">.</span> intercalate <span class="st">&quot; &quot;</span> <span class="fu">.</span> rowS
<span class="ot">&gt;</span>   <span class="kw">where</span> (names, wires) <span class="fu">=</span> unzip desc
<span class="ot">&gt;</span>         rows           <span class="fu">=</span> take count <span class="fu">.</span> transpose <span class="fu">.</span> map (\ (<span class="dt">Sig</span> w) <span class="ot">-&gt;</span> w) <span class="fu">$</span> wires
<span class="ot">&gt;</span>         rowS bs        <span class="fu">=</span> zipWith (\n b <span class="ot">-&gt;</span> replicate (length n <span class="fu">-</span> <span class="dv">1</span>) <span class="ch">' '</span> <span class="fu">++</span> (show (binary b))) names bs
<span class="ot">&gt;</span> 
<span class="ot">&gt; probe ::</span> [(<span class="dt">String</span>,<span class="dt">Signal</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> probe desc <span class="fu">=</span> trace desc <span class="dv">1</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; simulate ::</span> [(<span class="dt">String</span>, <span class="dt">Signal</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> simulate desc <span class="fu">=</span> trace desc <span class="dv">20</span></code></pre></div>
<h2 id="testing-support-quickcheck-helpers">Testing support (QuickCheck helpers)</h2>
<p>Next, we have a few functions that help to generate random tests</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Signal</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   arbitrary <span class="fu">=</span> <span class="kw">do</span> 
<span class="ot">&gt;</span>     x      <span class="ot">&lt;-</span> arbitrary
<span class="ot">&gt;</span>     <span class="dt">Sig</span> xs <span class="ot">&lt;-</span> arbitrary
<span class="ot">&gt;</span>     return <span class="fu">$</span> <span class="dt">Sig</span> (x <span class="fu">:</span> xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> arbitraryListOfSize n <span class="fu">=</span> forM [<span class="dv">1</span><span class="fu">..</span>n] <span class="fu">$</span> \_ <span class="ot">-&gt;</span> arbitrary</code></pre></div>
<p>To check whether two values are equivalent</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">Agreeable</span> a <span class="kw">where</span>
<span class="ot">&gt;   (===) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Agreeable</span> <span class="dt">Signal</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   (<span class="dt">Sig</span> as) <span class="fu">===</span> (<span class="dt">Sig</span> bs) <span class="fu">=</span> 
<span class="ot">&gt;</span>     all (\x<span class="ot">-&gt;</span>x) (zipWith (<span class="fu">==</span>) (truncateSig as) (truncateSig bs))
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">Agreeable</span> a, <span class="dt">Agreeable</span> b) <span class="ot">=&gt;</span> <span class="dt">Agreeable</span> (a,b) <span class="kw">where</span>
<span class="ot">&gt;</span>   (a1,b1) <span class="fu">===</span> (a2,b2) <span class="fu">=</span> (a1 <span class="fu">===</span> a2) <span class="fu">&amp;&amp;</span> (b1 <span class="fu">===</span> b2)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Agreeable</span> a <span class="ot">=&gt;</span> <span class="dt">Agreeable</span> [a] <span class="kw">where</span>
<span class="ot">&gt;</span>   as <span class="fu">===</span> bs <span class="fu">=</span> all (\x<span class="ot">-&gt;</span>x) (zipWith (<span class="fu">===</span>) as bs)</code></pre></div>
<p>To convert values from boolean to higher-level integers</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">class</span> <span class="dt">Binary</span> a <span class="kw">where</span>
<span class="ot">&gt;   binary ::</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Binary</span> <span class="dt">Bool</span> <span class="kw">where</span>
<span class="ot">&gt;</span>   binary b <span class="fu">=</span> <span class="kw">if</span> b <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Binary</span> [<span class="dt">Bool</span>] <span class="kw">where</span>
<span class="ot">&gt;</span>   binary <span class="fu">=</span> foldr (\x r <span class="ot">-&gt;</span> (binary x) <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span>r) <span class="dv">0</span></code></pre></div>
<p>And to probe signals at specific points.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> sampleAt n (<span class="dt">Sig</span> b) <span class="fu">=</span> b <span class="fu">!!</span> n
<span class="ot">&gt;</span> sampleAtN n signals <span class="fu">=</span> map (sampleAt n) signals
<span class="ot">&gt;</span> sample1 <span class="fu">=</span> sampleAt <span class="dv">0</span>
<span class="ot">&gt;</span> sampleN <span class="fu">=</span> sampleAtN <span class="dv">0</span></code></pre></div>
<h2 id="basic-gates">Basic Gates</h2>
<p>The basic gates from which we will fashion circuits can now be described.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; or2 ::</span>  (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> or2 <span class="fu">=</span> lift2 <span class="fu">$</span> \x y <span class="ot">-&gt;</span> x <span class="fu">||</span> y 
<span class="ot">&gt;</span> 
<span class="ot">&gt; xor2 ::</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> xor2 <span class="fu">=</span> lift2 <span class="fu">$</span> \x y <span class="ot">-&gt;</span> (x <span class="fu">&amp;&amp;</span> not y) <span class="fu">||</span> (not x <span class="fu">&amp;&amp;</span> y)
<span class="ot">&gt;</span> 
<span class="ot">&gt; and2 ::</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> and2 <span class="fu">=</span> lift2 <span class="fu">$</span> \x y <span class="ot">-&gt;</span> x <span class="fu">&amp;&amp;</span> y 
<span class="ot">&gt;</span> 
<span class="ot">&gt; imp2 ::</span>  (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> imp2 <span class="fu">=</span> lift2 <span class="fu">$</span> \x y <span class="ot">-&gt;</span> (not x) <span class="fu">||</span> y 
<span class="ot">&gt;</span> 
<span class="ot">&gt; mux ::</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> mux <span class="fu">=</span> lift3 (\b1 b2 select <span class="ot">-&gt;</span> <span class="kw">if</span> select <span class="kw">then</span> b1 <span class="kw">else</span> b2)
<span class="ot">&gt;</span> 
<span class="ot">&gt; demux ::</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>)
<span class="ot">&gt;</span> demux args <span class="fu">=</span> lift22 (\i select <span class="ot">-&gt;</span> <span class="kw">if</span> select <span class="kw">then</span> (i, <span class="dt">False</span>) <span class="kw">else</span> (<span class="dt">False</span>, i)) args
<span class="ot">&gt;</span> 
<span class="ot">&gt; muxN ::</span> ([<span class="dt">Signal</span>], [<span class="dt">Signal</span>], <span class="dt">Signal</span>) <span class="ot">-&gt;</span> [<span class="dt">Signal</span>]
<span class="ot">&gt;</span> muxN (b1,b2,sel) <span class="fu">=</span> map (\ (bb1,bb2) <span class="ot">-&gt;</span> mux (bb1,bb2,sel)) (zip b1 b2)
<span class="ot">&gt;</span> 
<span class="ot">&gt; demuxN ::</span> ([<span class="dt">Signal</span>], <span class="dt">Signal</span>) <span class="ot">-&gt;</span> ([<span class="dt">Signal</span>], [<span class="dt">Signal</span>])
<span class="ot">&gt;</span> demuxN (b,sel) <span class="fu">=</span> unzip (map (\bb <span class="ot">-&gt;</span> demux (bb,sel)) b)</code></pre></div>
<h2 id="basic-signals">Basic Signals</h2>
<p>Similarly, here are some basic signals</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> high <span class="fu">=</span> lift0 <span class="dt">True</span>
<span class="ot">&gt;</span> low  <span class="fu">=</span> lift0 <span class="dt">False</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; str   ::</span>  <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> str cs <span class="fu">=</span> <span class="dt">Sig</span> <span class="fu">$</span> (map (<span class="fu">==</span> <span class="ch">'1'</span>) cs) <span class="fu">++</span> (repeat <span class="dt">False</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; delay ::</span>  <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Signal</span> <span class="ot">-&gt;</span> <span class="dt">Signal</span>
<span class="ot">&gt;</span> delay init (<span class="dt">Sig</span> xs) <span class="fu">=</span> <span class="dt">Sig</span> <span class="fu">$</span> init <span class="fu">:</span> xs</code></pre></div>
<h2 id="combinational-circuits">Combinational circuits</h2>
<p><strong>NOTE</strong> When you are asked to implement a circuit, you must <strong>ONLY</strong> use the above gates or smaller circuits built from the gates.</p>
<p>For example, the following is a <em>half-adder</em> (that adds a carry-bit to a single bit).</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; halfadd ::</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>) <span class="ot">-&gt;</span> (<span class="dt">Signal</span>, <span class="dt">Signal</span>)
<span class="ot">&gt;</span> halfadd (x,y) <span class="fu">=</span> (sum,cout)
<span class="ot">&gt;</span>   <span class="kw">where</span> sum   <span class="fu">=</span> xor2 (x, y)
<span class="ot">&gt;</span>         cout  <span class="fu">=</span> and2 (x, y)</code></pre></div>
<p>Here is a simple property about the half-adder</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> prop_halfadd_commut b1 b2 <span class="fu">=</span>
<span class="ot">&gt;</span>   halfadd (lift0 b1, lift0 b2) <span class="fu">===</span> halfadd (lift0 b2, lift0 b1) </code></pre></div>
<p>We can use the half-adder to build a full-adder</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> fulladd (cin, x, y) <span class="fu">=</span> (sum, cout)
<span class="ot">&gt;</span>   <span class="kw">where</span> (sum1, c1)  <span class="fu">=</span> halfadd (x,y)
<span class="ot">&gt;</span>         (sum, c2)   <span class="fu">=</span> halfadd (cin, sum1)
<span class="ot">&gt;</span>         cout        <span class="fu">=</span> xor2 (c1,c2) 
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> test1a <span class="fu">=</span> probe [(<span class="st">&quot;cin&quot;</span>,cin), (<span class="st">&quot;x&quot;</span>,x), (<span class="st">&quot;y&quot;</span>,y), (<span class="st">&quot;  sum&quot;</span>,sum), (<span class="st">&quot;cout&quot;</span>,cout)]
<span class="ot">&gt;</span>   <span class="kw">where</span> cin        <span class="fu">=</span> high
<span class="ot">&gt;</span>         x          <span class="fu">=</span> low
<span class="ot">&gt;</span>         y          <span class="fu">=</span> high
<span class="ot">&gt;</span>         (sum,cout) <span class="fu">=</span> fulladd (cin, x, y)</code></pre></div>
<p>and then an n-bit adder</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; bitAdder ::</span> (<span class="dt">Signal</span>, [<span class="dt">Signal</span>]) <span class="ot">-&gt;</span> ([<span class="dt">Signal</span>], <span class="dt">Signal</span>)
<span class="ot">&gt;</span> bitAdder (cin, [])   <span class="fu">=</span> ([], cin)
<span class="ot">&gt;</span> bitAdder (cin, x<span class="fu">:</span>xs) <span class="fu">=</span> (sum<span class="fu">:</span>sums, cout)
<span class="ot">&gt;</span>   <span class="kw">where</span> (sum, c)     <span class="fu">=</span> halfadd (cin,x)
<span class="ot">&gt;</span>         (sums, cout) <span class="fu">=</span> bitAdder (c,xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> test1 <span class="fu">=</span> probe [(<span class="st">&quot;cin&quot;</span>,cin), (<span class="st">&quot;in1&quot;</span>,in1), (<span class="st">&quot;in2&quot;</span>,in2), (<span class="st">&quot;in3&quot;</span>,in3), (<span class="st">&quot;in4&quot;</span>,in4),
<span class="ot">&gt;</span>                (<span class="st">&quot;  s1&quot;</span>,s1), (<span class="st">&quot;s2&quot;</span>,s2), (<span class="st">&quot;s3&quot;</span>,s3), (<span class="st">&quot;s4&quot;</span>,s4), (<span class="st">&quot;c&quot;</span>,c)]
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;</span>     cin <span class="fu">=</span> high
<span class="ot">&gt;</span>     in1 <span class="fu">=</span> high
<span class="ot">&gt;</span>     in2 <span class="fu">=</span> high
<span class="ot">&gt;</span>     in3 <span class="fu">=</span> low
<span class="ot">&gt;</span>     in4 <span class="fu">=</span> high
<span class="ot">&gt;</span>     ([s1,s2,s3,s4], c) <span class="fu">=</span> bitAdder (cin, [in1,in2,in3,in4])</code></pre></div>
<p>The correctness of the above circuit is described by the following property that compares the behavior of the circuit to the <em>reference implementation</em> which is an integer addition function</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_bitAdder_Correct ::</span>  <span class="dt">Signal</span> <span class="ot">-&gt;</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_bitAdder_Correct cin xs <span class="fu">=</span>
<span class="ot">&gt;</span>   binary (sampleN out <span class="fu">++</span> [sample1 cout]) <span class="fu">==</span> binary xs <span class="fu">+</span> binary (sample1 cin)
<span class="ot">&gt;</span>   <span class="kw">where</span> (out, cout) <span class="fu">=</span> bitAdder (cin, map lift0 xs) </code></pre></div>
<p>Finally, we can use the bit-adder to build an adder that adds two N-bit numbers</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; adder ::</span> ([<span class="dt">Signal</span>], [<span class="dt">Signal</span>]) <span class="ot">-&gt;</span> [<span class="dt">Signal</span>]
<span class="ot">&gt;</span> adder (xs, ys) <span class="fu">=</span> 
<span class="ot">&gt;</span>    <span class="kw">let</span> (sums,cout) <span class="fu">=</span> adderAux (low, xs, ys)
<span class="ot">&gt;</span>    <span class="kw">in</span> sums <span class="fu">++</span> [cout]
<span class="ot">&gt;</span>    <span class="kw">where</span>                                        
<span class="ot">&gt;</span>      adderAux (cin, [], [])     <span class="fu">=</span> ([], cin)
<span class="ot">&gt;</span>      adderAux (cin, x<span class="fu">:</span>xs, y<span class="fu">:</span>ys) <span class="fu">=</span> (sum<span class="fu">:</span>sums, cout)
<span class="ot">&gt;</span>                                   <span class="kw">where</span> (sum, c) <span class="fu">=</span> fulladd (cin,x,y)
<span class="ot">&gt;</span>                                         (sums,cout) <span class="fu">=</span> adderAux (c,xs,ys)
<span class="ot">&gt;</span>      adderAux (cin, [], ys)     <span class="fu">=</span> adderAux (cin, [low], ys)
<span class="ot">&gt;</span>      adderAux (cin, xs, [])     <span class="fu">=</span> adderAux (cin, xs, [low])
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> test2 <span class="fu">=</span> probe [ (<span class="st">&quot;x1&quot;</span>, x1), (<span class="st">&quot;x2&quot;</span>,x2), (<span class="st">&quot;x3&quot;</span>,x3), (<span class="st">&quot;x4&quot;</span>,x4),
<span class="ot">&gt;</span>                 (<span class="st">&quot; y1&quot;</span>,y1), (<span class="st">&quot;y2&quot;</span>,y2), (<span class="st">&quot;y3&quot;</span>,y3), (<span class="st">&quot;y4&quot;</span>,y4), 
<span class="ot">&gt;</span>                 (<span class="st">&quot; s1&quot;</span>,s1), (<span class="st">&quot;s2&quot;</span>,s2), (<span class="st">&quot;s3&quot;</span>,s3), (<span class="st">&quot;s4&quot;</span>,s4), (<span class="st">&quot; c&quot;</span>,c) ]
<span class="ot">&gt;</span>   <span class="kw">where</span> xs<span class="fu">@</span>[x1,x2,x3,x4] <span class="fu">=</span> [high,high,low,low]
<span class="ot">&gt;</span>         ys<span class="fu">@</span>[y1,y2,y3,y4] <span class="fu">=</span> [high,low,low,low]
<span class="ot">&gt;</span>         [s1,s2,s3,s4,c]  <span class="fu">=</span> adder (xs, ys)</code></pre></div>
<p>And we can specify the correctness of the adder circuit by</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_Adder_Correct ::</span>  [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_Adder_Correct l1 l2 <span class="fu">=</span> 
<span class="ot">&gt;</span>   binary (sampleN sum) <span class="fu">==</span> binary l1 <span class="fu">+</span> binary l2
<span class="ot">&gt;</span>   <span class="kw">where</span> sum <span class="fu">=</span> adder (map lift0 l1, map lift0 l2) </code></pre></div>
<h2 id="problem-subtraction">Problem: Subtraction</h2>
<ol style="list-style-type: decimal">
<li>Using <code>prop_bitAdder_Correct</code> as a model, write a speciﬁcation for a single-bit subtraction function that takes as inputs a N-bit binary number and a single bit to be subtracted from it and yields as outputs an N-bit binary number. Subtracting one from zero should yield zero.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_bitSubtractor_Correct ::</span>  <span class="dt">Signal</span> <span class="ot">-&gt;</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_bitSubtractor_Correct <span class="fu">=</span> error <span class="st">&quot;TODO&quot;</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li>Using the <code>bitAdder</code> circuit as a model, deﬁne a <code>bitSubtractor</code> circuit that implements this functionality and use QC to check that your behaves correctly.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; bitSubtractor ::</span> (<span class="dt">Signal</span>, [<span class="dt">Signal</span>]) <span class="ot">-&gt;</span> ([<span class="dt">Signal</span>], <span class="dt">Signal</span>)
<span class="ot">&gt;</span> bitSubtractor <span class="fu">=</span> error <span class="st">&quot;TODO&quot;</span></code></pre></div>
<h2 id="problem-multiplication">Problem: Multiplication</h2>
<ol start="3" style="list-style-type: decimal">
<li>Using <code>prop_Adder_Correct</code> as a model, write down a QC speciﬁcation for a <code>multiplier</code> circuit that takes two binary numbers of arbitrary width as input and outputs their product.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_Multiplier_Correct ::</span>  [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_Multiplier_Correct <span class="fu">=</span> error <span class="st">&quot;TODO&quot;</span></code></pre></div>
<ol start="4" style="list-style-type: decimal">
<li>Deﬁne a <code>multiplier</code> circuit and check that it satisﬁes your speciﬁcation. (Looking at how adder is deﬁned will help with this, but you’ll need a little more wiring. To get an idea of how the recursive structure should work, think about how to multiply two binary numbers on paper.)</li>
</ol>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; multiplier ::</span> ([<span class="dt">Signal</span>], [<span class="dt">Signal</span>]) <span class="ot">-&gt;</span> [<span class="dt">Signal</span>]
<span class="ot">&gt;</span> multiplier <span class="fu">=</span> error <span class="st">&quot;TODO&quot;</span></code></pre></div>
    </body>

    <div id="footer"> 
      Site generated with <a href="http://jaspervdj.be/hakyll">hakyll</a>
    </div> 
</html>
